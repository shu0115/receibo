<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Ruby on Rails Guides: Getting Started with Engines</title>

<link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" />

<link rel="stylesheet" type="text/css" href="stylesheets/fixes.css" />
</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong>More at <a href="http://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <a href="http://rubyonrails.org/">Overview</a> |
      <a href="http://rubyonrails.org/download">Download</a> |
      <a href="http://rubyonrails.org/deploy">Deploy</a> |
      <a href="https://github.com/rails/rails">Code</a> |
      <a href="http://rubyonrails.org/screencasts">Screencasts</a> |
      <a href="http://rubyonrails.org/documentation">Documentation</a> |
      <a href="http://rubyonrails.org/ecosystem">Ecosystem</a> |
      <a href="http://rubyonrails.org/community">Community</a> |
      <a href="http://weblog.rubyonrails.org/">Blog</a>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Return to home page">Guides.rubyonrails.org</a></h1>
      <p class="hide"><a href="#mainCol">Skip navigation</a>.</p>
      <ul class="nav">
        <li><a href="index.html">Home</a></li>
        <li class="index"><a href="index.html" onclick="guideMenu(); return false;" id="guidesMenu">Guides Index</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="L">
              <dt>Start Here</dt>
              <dd><a href="getting_started.html">Getting Started with Rails</a></dd>
              <dt>Models</dt>
              <dd><a href="migrations.html">Rails Database Migrations</a></dd>
              <dd><a href="active_record_validations_callbacks.html">Active Record Validations and Callbacks</a></dd>
              <dd><a href="association_basics.html">Active Record Associations</a></dd>
              <dd><a href="active_record_querying.html">Active Record Query Interface</a></dd>
              <dt>Views</dt>
              <dd><a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
              <dd><a href="form_helpers.html">Action View Form Helpers</a></dd>
              <dt>Controllers</dt>
              <dd><a href="action_controller_overview.html">Action Controller Overview</a></dd>
              <dd><a href="routing.html">Rails Routing from the Outside In</a></dd>
            </dl>
            <dl class="R">
              <dt>Digging Deeper</dt>
              <dd><a href="active_support_core_extensions.html">Active Support Core Extensions</a></dd>
              <dd><a href="i18n.html">Rails Internationalization API</a></dd>
              <dd><a href="action_mailer_basics.html">Action Mailer Basics</a></dd>
              <dd><a href="testing.html">Testing Rails Applications</a></dd>
              <dd><a href="security.html">Securing Rails Applications</a></dd>
              <dd><a href="debugging_rails_applications.html">Debugging Rails Applications</a></dd>
              <dd><a href="performance_testing.html">Performance Testing Rails Applications</a></dd>
              <dd><a href="configuring.html">Configuring Rails Applications</a></dd>
              <dd><a href="command_line.html">Rails Command Line Tools and Rake Tasks</a></dd>
              <dd><a href="caching_with_rails.html">Caching with Rails</a></dd>
              <dd><a href="asset_pipeline.html">Asset Pipeline</a></dd>

              <dt>Extending Rails</dt>
              <dd><a href="plugins.html">The Basics of Creating Rails Plugins</a></dd>
              <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
              <dd><a href="generators.html">Creating and Customizing Rails Generators</a></dd>

              <dt>Contributing to Ruby on Rails</dt>
              <dd><a href="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</a></dd>
              <dd><a href="api_documentation_guidelines.html">API Documentation Guidelines</a></dd>
              <dd><a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a></dd>

              <dt>Release Notes</dt>
              <dd><a href="3_1_release_notes.html">Ruby on Rails 3.1 Release Notes</a></dd>
              <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes</a></dd>
              <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes</a></dd>
              <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes</a></dd>
            </dl>
          </div>
        </li>
        <li><a href="contributing_to_ruby_on_rails.html">Contribute</a></li>
        <li><a href="credits.html">Credits</a></li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>Getting Started with Engines</h2>
<p>In this guide you will learn about engines and how they can be used to provide additional functionality to their host applications through a clean and very easy-to-use interface. You will learn the following things in this guide:</p>
<ul>
	<li>What makes an engine</li>
	<li>How to generate an engine</li>
	<li>Building features for the engine</li>
	<li>Hooking the engine into an application</li>
	<li>Overriding engine functionality in the application</li>
</ul>

            <div id="subCol">
        <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
        <ol class="chapters">
<li><a href="#what-are-engines">What are engines?</a></li><li><a href="#generating-an-engine">Generating an engine</a><ul><li><a href="#inside-an-engine">Inside an engine</a></li></ul></li><li><a href="#providing-engine-functionality">Providing engine functionality</a><ul><li><a href="#generating-a-post-resource">Generating a post resource</a></li> <li><a href="#generating-a-comments-resource">Generating a comments resource</a></li></ul></li><li><a href="#hooking-into-an-application">Hooking into an application</a><ul><li><a href="#mounting-the-engine">Mounting the engine</a></li> <li><a href="#engine-setup">Engine setup</a></li> <li><a href="#using-a-class-provided-by-the-application">Using a class provided by the application</a></li> <li><a href="#configuring-an-engine">Configuring an engine</a></li></ul></li><li><a href="#extending-engine-functionality">Extending engine functionality</a><ul><li><a href="#overriding-views">Overriding views</a></li> <li><a href="#controllers">Controllers</a></li> <li><a href="#models">Models</a></li> <li><a href="#routes">Routes</a></li></ul></li></ol></div>
    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="what-are-engines">1 What are engines?</h3>
<p>Engines can be considered miniature applications that provide functionality to their host applications. A Rails application is actually just a &#8220;supercharged&#8221; engine, with the <tt>Rails::Application</tt> class inheriting from <tt>Rails::Engine</tt>. Therefore, engines and applications share common functionality but are at the same time two separate beasts. Engines and applications also share a common structure, as you&#8217;ll see throughout this guide.</p>
<p>Engines are also closely related to plugins where the two share a common <tt>lib</tt> directory structure and are both generated using the <tt>rails plugin new</tt> generator.</p>
<p>The engine that will be generated for this guide will be called &#8220;blorgh&#8221;. The engine will provide blogging functionality to its host applications, allowing for new posts and comments to be created. For now, you will be working solely within the engine itself and in later sections you&#8217;ll see how to hook it into an application.</p>
<p>Engines can also be isolated from their host applications. This means that an application is able to have a path provided by a routing helper such as <tt>posts_path</tt> and use an engine also that provides a path also called <tt>posts_path</tt>, and the two would not clash. Along with this, controllers, models and table names are also namespaced. You&#8217;ll see how to do this later in this guide.</p>
<p>To see demonstrations of other engines, check out <a href="https://github.com/plataformatec/devise">Devise</a>, an engine that provides authentication for its parent applications, or <a href="https://github.com/radar/forem">Forem</a>, an engine that provides forum functionality.</p>
<p>Finally, engines would not have be possible without the work of James Adam, Piotr Sarnacki, the Rails Core Team, and a number of other people. If you ever meet them, don&#8217;t forget to say thanks!</p>
<h3 id="generating-an-engine">2 Generating an engine</h3>
<p>To generate an engine with Rails 3.1, you will need to run the plugin generator and pass it the <tt>--mountable</tt> option. To generate the beginnings of the &#8220;blorgh&#8221; engine you will need to run this command in a terminal:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails plugin new blorgh --mountable
</pre>
</div>
<p>The <tt>--mountable</tt> option tells the plugin generator that you want to create an engine (which is a mountable plugin, hence the option name), creating the basic directory structure of an engine by providing things such as the foundations of an <tt>app</tt> folder, as well a <tt>config/routes.rb</tt> file. This generator also provides a file at <tt>lib/blorgh/engine.rb</tt> which is identical in function to an application&#8217;s <tt>config/application.rb</tt> file.</p>
<h4 id="inside-an-engine">2.1 Inside an engine</h4>
<h5 id="critical-files">2.1.1 Critical files</h5>
<p>At the root of the engine&#8217;s directory, lives a <tt>blorgh.gemspec</tt> file. When you include the engine into the application later on, you will do so with this line in a Rails application&#8217;s <tt>Gemfile</tt>:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
gem 'blorgh', :path =&gt; &quot;vendor/engines/blorgh&quot;
</pre>
</div>
<p>By specifying it as a gem within the <tt>Gemfile</tt>, Bundler will load it as such, parsing this <tt>blorgh.gemspec</tt> file and requiring a file within the <tt>lib</tt> directory called <tt>lib/blorgh.rb</tt>. This file requires the <tt>blorgh/engine.rb</tt> file (located at <tt>lib/blorgh/engine.rb</tt>) and defines a base module called <tt>Blorgh</tt>.</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;blorgh/engine&quot;

module Blorgh
end
</pre>
</div>
<p>Within <tt>lib/blorgh/engine.rb</tt> is the base class for the engine:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Blorgh
  class Engine &lt; Rails::Engine
    isolate_namespace Blorgh
  end
end
</pre>
</div>
<p>By inheriting from the <tt>Rails::Engine</tt> class, this engine gains all the functionality it needs, such as being able to serve requests to its controllers.</p>
<p>The <tt>isolate_namespace</tt> method here deserves special notice. This call is responsible for isolating the controllers, models, routes and other things into their own namespace. Without this, there is a possibility that the engine&#8217;s components could &#8220;leak&#8221; into the application, causing unwanted disruption. It is recommended that this line be left within this file.</p>
<h5 id="app-directory">2.1.2 <tt>app</tt> directory</h5>
<p>Inside the <tt>app</tt> directory there lives the standard <tt>assets</tt>, <tt>controllers</tt>, <tt>helpers</tt>, <tt>mailers</tt>, <tt>models</tt> and <tt>views</tt> directories that you should be familiar with from an application. The <tt>helpers</tt>, <tt>mailers</tt> and <tt>models</tt> directories are empty and so aren&#8217;t described in this section. We&#8217;ll look more into models in a future section.</p>
<p>Within the <tt>app/assets</tt> directory, there is the <tt>images</tt>, <tt>javascripts</tt> and <tt>stylesheets</tt> directories which, again, you should be familiar with due to their similarities of an application. One difference here however is that each directory contains a sub-directory with the engine name. Because this engine is going to be namespaced, its assets should be too.</p>
<p>Within the <tt>app/controllers</tt> directory there is a <tt>blorgh</tt> directory and inside that a file called <tt>application_controller.rb</tt>. This file will provide any common functionality for the controllers of the engine. The <tt>blorgh</tt> directory is where the other controllers for the engine will go. By placing them within this namespaced directory, you prevent them from possibly clashing with identically-named controllers within other engines or even within the application.</p>
<p>Lastly, the <tt>app/views</tt> directory contains a <tt>layouts</tt> folder which contains file at <tt>blorgh/application.html.erb</tt> which allows you to specify a layout for the engine. If this engine is to be used as a stand-alone engine, then you would add any customization to its layout in this file, rather than the applications <tt>app/views/layouts/application.html.erb</tt> file.</p>
<h5 id="script-directory">2.1.3 <tt>script</tt> directory</h5>
<p>This directory contains one file, <tt>script/rails</tt>, which allows you to use the <tt>rails</tt> sub-commands and generators just like you would within an application. This means that you will very easily be able to generate new controllers and models for this engine.</p>
<h5 id="test-directory">2.1.4 <tt>test</tt> directory</h5>
<p>The <tt>test</tt> directory is where tests for the engine will go. To test the engine, there is a cut-down version of a Rails application embedded within it at <tt>test/dummy</tt>. This application will mount the engine in the <tt>test/dummy/config/routes.rb</tt> file:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Rails.application.routes.draw do

  mount Blorgh::Engine =&gt; &quot;/blorgh&quot;
end
</pre>
</div>
<p>This line mounts the engine at the path of <tt>/blorgh</tt>, which will make it accessible through the application only at that path. We will look more into mounting an engine after some features have been developed.</p>
<p>Also in the test directory is the <tt>test/integration</tt> directory, where integration tests for the engine should be placed.</p>
<h3 id="providing-engine-functionality">3 Providing engine functionality</h3>
<p>The engine that this guide covers will provide posting and commenting functionality and follows a similar thread to the <a href="getting-started.html">Getting Started Guide</a>, with some new twists.</p>
<h4 id="generating-a-post-resource">3.1 Generating a post resource</h4>
<p>The first thing to generate for a blog engine is the <tt>Post</tt> model and related controller. To quickly generate this, you can use the Rails scaffold generator.</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate scaffold post title:string text:text
</pre>
</div>
<p>This command will output this information:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_posts.rb
create    app/models/blorgh/post.rb
invoke    test_unit
create      test/unit/blorgh/post_test.rb
create      test/fixtures/blorgh/posts.yml
 route  resources :posts
invoke  scaffold_controller
create    app/controllers/blorgh/posts_controller.rb
invoke    erb
create      app/views/blorgh/posts
create      app/views/blorgh/posts/index.html.erb
create      app/views/blorgh/posts/edit.html.erb
create      app/views/blorgh/posts/show.html.erb
create      app/views/blorgh/posts/new.html.erb
create      app/views/blorgh/posts/_form.html.erb
invoke    test_unit
create      test/functional/blorgh/posts_controller_test.rb
invoke    helper
create      app/helpers/blorgh/posts_helper.rb
invoke      test_unit
create        test/unit/helpers/blorgh/posts_helper_test.rb
invoke  assets
invoke    js
create      app/assets/javascripts/blorgh/posts.js
invoke    css
create      app/assets/stylesheets/blorgh/posts.css
invoke  css
create    app/assets/stylesheets/scaffold.css
</pre>
</div>
<p>The first thing that the scaffold generator does is invoke the <tt>active_record</tt> generator, which generates a migration and a model for the resource. Note here, however, that the migration is called <tt>create_blorgh_posts</tt> rather than the usual <tt>create_posts</tt>. This is due to the <tt>isolate_namespace</tt> method called in the <tt>Blorgh::Engine</tt> class&#8217;s definition. The model here is also namespaced, being placed at <tt>app/models/blorgh/post.rb</tt> rather than <tt>app/models/post.rb</tt>.</p>
<p>Next, the <tt>test_unit</tt> generator is invoked for this model, generating a unit test at <tt>test/unit/blorgh/post_test.rb</tt> (rather than <tt>test/unit/post_test.rb</tt>) and a fixture at <tt>test/fixtures/blorgh/posts.yml</tt> (rather than <tt>test/fixtures/posts.yml</tt>).</p>
<p>After that, a line for the resource is inserted into the <tt>config/routes.rb</tt> file for the engine. This line is simply <tt>resources :posts</tt>, turning the <tt>config/routes.rb</tt> file into this:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Blorgh::Engine.routes.draw do
  resources :posts

end
</pre>
</div>
<p>Note here that the routes are drawn upon the <tt>Blorgh::Engine</tt> object rather than the <tt>YourApp::Application</tt> class. This is so that the engine routes are confined to the engine itself and can be mounted at a specific point as shown in the <a href="#test-directory">test directory</a> section.</p>
<p>Next, the <tt>scaffold_controller</tt> generator is invoked, generating a controlled called <tt>Blorgh::PostsController</tt> (at <tt>app/controllers/blorgh/posts_controller.rb</tt>) and its related views at <tt>app/views/blorgh/posts</tt>. This generator also generates a functional test for the controller (<tt>test/functional/blorgh/posts_controller_test.rb</tt>) and a helper (<tt>app/helpers/blorgh/posts_controller.rb</tt>).</p>
<p>Everything this generator has generated is neatly namespaced. The controller&#8217;s class is defined within the <tt>Blorgh</tt> module:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Blorgh
  class PostsController &lt; ApplicationController
    ...
  end
end
</pre>
</div>
<div class="note"><p>The <tt>ApplicationController</tt> class being inherited from here is the <tt>Blorgh::ApplicationController</tt>, not an application&#8217;s <tt>ApplicationController</tt>.</p></div>
<p>The helper is also namespaced:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Blorgh
  class PostsHelper
    ...
  end
end
</pre>
</div>
<p>This helps prevent conflicts with any other engine or application that may have a post resource also.</p>
<p>Finally, two files that are the assets for this resource are generated, <tt>app/assets/javascripts/blorgh/posts.js</tt> and <tt>app/assets/javascripts/blorgh/posts.css</tt>. You&#8217;ll see how to use these a little later.</p>
<p>By default, the scaffold styling is not applied to the engine as the engine&#8217;s layout file, <tt>app/views/blorgh/application.html.erb</tt> doesn&#8217;t load it. To make this apply, insert this line into the <tt><head></tt> tag of this layout:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= stylesheet_link_tag &quot;scaffold&quot; %&gt;
</pre>
</div>
<p>You can see what the engine has so far by running <tt>rake db:migrate</tt> at the root of our engine to run the migration generated by the scaffold generator, and then running <tt>rails server</tt>. When you open <tt>http://localhost:3000/blorgh/posts</tt> you will see the default scaffold that has been generated.</p>
<p><img src="images/engines_scaffold.png" title="Blank engine scaffold" alt="Blank engine scaffold" /></p>
<p>Click around! You&#8217;ve just generated your first engine&#8217;s first functions.</p>
<p>If you&#8217;d rather play around in the console, <tt>rails console</tt> will also work just like a Rails application. Remember: the <tt>Post</tt> model is namespaced, so to reference it you must call it as <tt>Blorgh::Post</tt>.</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
&gt;&gt; Blorgh::Post.find(1)
  =&gt; #&lt;Blorgh::Post id: 1 ...&gt;
</pre>
</div>
<p>One final thing is that the <tt>posts</tt> resource for this engine should be the root of the engine. Whenever someone goes to the root path where the engine is mounted, they should be shown a list of posts. This can be made to happen if this line is inserted into the <tt>config/routes.rb</tt> file inside the engine:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
root :to =&gt; &quot;posts#index&quot;
</pre>
</div>
<p>Now people will only need to go to the root of the engine to see all the posts, rather than visiting <tt>/posts</tt>.</p>
<h4 id="generating-a-comments-resource">3.2 Generating a comments resource</h4>
<p>Now that the engine has the ability to create new blog posts, it only makes sense to add commenting functionality as well. To do get this, you&#8217;ll need to generate a comment model, a comment controller and then modify the posts scaffold to display comments and allow people to create new ones.</p>
<p>Run the model generator and tell it to generate a <tt>Comment</tt> model, with the related table having two columns: a <tt>post_id</tt> integer and <tt>text</tt> text column.</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate model Comment post_id:integer text:text
</pre>
</div>
<p>This will output the following:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_comments.rb
create    app/models/blorgh/comment.rb
invoke    test_unit
create      test/unit/blorgh/comment_test.rb
create      test/fixtures/blorgh/comments.yml
</pre>
</div>
<p>This generator call will generate just the necessary model files it needs, namespacing the files under a <tt>blorgh</tt> directory and creating a model class called <tt>Blorgh::Comment</tt>.</p>
<p>To show the comments on a post, edit <tt>app/views/posts/show.html.erb</tt> and add this line before the &#8220;Edit&#8221; link:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h3&gt;Comments&lt;/h3&gt;
&lt;%= render @post.comments %&gt;
</pre>
</div>
<p>This line will require there to be a <tt>has_many</tt> association for comments defined on the <tt>Blorgh::Post</tt> model, which there isn&#8217;t right now. To define one, open <tt>app/models/blorgh/post.rb</tt> and add this line into the model:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
has_many :comments
</pre>
</div>
<p>Turning the model into this:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Blorgh
  class Post &lt; ActiveRecord::Base
    has_many :comments
  end
end
</pre>
</div>
<p>Because the <tt>has_many</tt> is defined inside a class that is inside the <tt>Blorgh</tt> module, Rails will know that you want to use the <tt>Blorgh::Comment</tt> model for these objects.</p>
<p>Next, there needs to be a form so that comments can be created on a post. To add this, put this line underneath the call to <tt>render @post.comments</tt> in <tt>app/views/blorgh/posts/show.html.erb</tt>:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= render &quot;blorgh/comments/form&quot; %&gt;
</pre>
</div>
<p>Next, the partial that this line will render needs to exist. Create a new directory at <tt>app/views/blorgh/comments</tt> and in it a new file called <tt>_form.html.erb</tt> which has this content to create the required partial:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h3&gt;New comment&lt;/h3&gt;
&lt;%= form_for [@post, @post.comments.build] do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :text %&gt;&lt;br /&gt;
    &lt;%= f.text_area :text %&gt;
  &lt;/p&gt;
  &lt;%= f.submit %&gt;
&lt;% end %&gt;
</pre>
</div>
<p>This form, when submitted, is going to attempt to post to a route of <tt>posts/:post_id/comments</tt> within the engine. This route doesn&#8217;t exist at the moment, but can be created by changing the <tt>resources :posts</tt> line inside <tt>config/routes.rb</tt> into these lines:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :posts do
  resources :comments
end
</pre>
</div>
<p>The route now will exist, but the controller that this route goes to does not. To create it, run this command:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails g controller comments
</pre>
</div>
<p>This will generate the following things:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
create  app/controllers/blorgh/comments_controller.rb
invoke  erb
 exist    app/views/blorgh/comments
invoke  test_unit
create    test/functional/blorgh/comments_controller_test.rb
invoke  helper
create    app/helpers/blorgh/comments_helper.rb
invoke    test_unit
create      test/unit/helpers/blorgh/comments_helper_test.rb
invoke  assets
invoke    js
create      app/assets/javascripts/blorgh/comments.js
invoke    css
create      app/assets/stylesheets/blorgh/comments.css
</pre>
</div>
<p>The form will be making a <tt>POST</tt> request to <tt>/posts/:post_id/comments</tt>, which will correspond with the <tt>create</tt> action in <tt>Blorgh::CommentsController</tt>. This action needs to be created and can be done by putting the following lines inside the class definition in <tt>app/controllers/blorgh/comments_controller.rb</tt>:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  @post = Post.find(params[:post_id])
  @comment = @post.comments.build(params[:comment])
  flash[:notice] = &quot;Comment has been created!&quot;
  redirect_to post_path
end
</pre>
</div>
<p>This is the final part required to get the new comment form working. Displaying the comments however, is not quite right yet. If you were to create a comment right now you would see this error:</p>
<text>
Missing partial blorgh/comments/comment with {:handlers=&gt;[:erb, :builder], :formats=&gt;[:html], :locale=&gt;[:en, :en]}. Searched in:
<ul>
	<li>&#8220;/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views&#8221;</li>
	<li>&#8220;/Users/ryan/Sites/side_projects/blorgh/app/views&#8221;
</text></li>
</ul>
<p>The engine is unable to find the partial required for rendering the comments. Rails has looked firstly in the application&#8217;s (<tt>test/dummy</tt>) <tt>app/views</tt> directory and then in the engine&#8217;s <tt>app/views</tt> directory. When it can&#8217;t find it, it will throw this error. The engine knows to look for <tt>blorgh/comments/comment</tt> because the model object it is receiving is from the <tt>Blorgh::Comment</tt> class.</p>
<p>This partial will be responsible for rendering just the comment text, for now. Create a new file at <tt>app/views/blorgh/comments/_comment.html.erb</tt> and put this line inside it:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= comment_counter + 1 %&gt;. &lt;%= comment.text %&gt;
</pre>
</div>
<p>The <tt>comment_counter</tt> local variable is given to us by the <tt><%= render @post.comments %></tt> call, as it will define this automatically and increment the counter as it iterates through each comment. It&#8217;s used in this example to display a small number next to each comment when it&#8217;s created.</p>
<p>That completes the comment function of the blogging engine. Now it&#8217;s time to use it within an application.</p>
<h3 id="hooking-into-an-application">4 Hooking into an application</h3>
<p>Using an engine within an application is very easy. This section covers how to mount the engine into an application and the initial setup required for it, as well as linking the engine to a <tt>User</tt> class provided by the application to provide ownership for posts and comments within the engine.</p>
<h4 id="mounting-the-engine">4.1 Mounting the engine</h4>
<p>First, the engine needs to be specified inside the application&#8217;s <tt>Gemfile</tt>. If there isn&#8217;t an application handy to test this out in, generate one using the <tt>rails new</tt> command outside of the engine directory like this:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails new unicorn
</pre>
</div>
<p>Usually, specifying the engine inside the Gemfile would be done by specifying it as a normal, everyday gem.</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
gem 'devise'
</pre>
</div>
<p>Because the <tt>blorgh</tt> engine is still under development, it will need to have a <tt>:path</tt> option for its <tt>Gemfile</tt> specification:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
gem 'blorgh', :path =&gt; &quot;/path/to/blorgh&quot;
</pre>
</div>
<p>If the whole <tt>blorgh</tt> engine directory is copied to <tt>vendor/engines/blorgh</tt> then it could be specified in the <tt>Gemfile</tt> like this:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
gem 'blorgh', :path =&gt; &quot;vendor/engines/blorgh&quot;
</pre>
</div>
<p>As described earlier, by placing the gem in the <tt>Gemfile</tt> it will be loaded when Rails is loaded, as it will first require <tt>lib/blorgh.rb</tt> in the engine and then <tt>lib/blorgh/engine.rb</tt>, which is the file that defines the major pieces of functionality for the engine.</p>
<p>To make the engine&#8217;s functionality accessible from within an application, it needs to be mounted in that application&#8217;s <tt>config/routes.rb</tt> file:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
mount Blorgh::Engine, :at =&gt; &quot;blog&quot;
</pre>
</div>
<p>This line will mount the engine at <tt>blog</tt> in the application. Making it accessible at <tt>http://localhost:3000/blog</tt> when the application runs with <tt>rails s</tt>.</p>
<div class="note"><p>Other engines, such as Devise, handle this a little differently by making you specify custom helpers such as <tt>devise_for</tt> in the routes. These helpers do exactly the same thing, mounting pieces of the engines&#8217;s functionality at a pre-defined path which may be customizable.</p></div>
<h4 id="engine-setup">4.2 Engine setup</h4>
<p>The engine contains migrations for the <tt>blorgh_posts</tt> and <tt>blorgh_comments</tt> table which need to be created in the application&#8217;s database so that the engine&#8217;s models can query them correctly. To copy these migrations into the application use this command:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake blorgh:install:migrations
</pre>
</div>
<p>This command, when run for the first time will copy over all the migrations from the engine. When run the next time, it will only copy over migrations that haven&#8217;t been copied over already. The first run for this command will output something such as this:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
Copied migration [timestamp_1]_create_blorgh_posts.rb from blorgh
Copied migration [timestamp_2]_create_blorgh_comments.rb from blorgh
</pre>
</div>
<p>The first timestamp (<tt>\[timestamp_1\]</tt>) will be the current time and the second timestamp (<tt>\[timestamp_2\]</tt>) will be the current time plus a second. The reason for this is so that the migrations for the engine are run after any existing migrations in the application.</p>
<p>To run these migrations within the context of the application, simply run <tt>rake db:migrate</tt>. When accessing the engine through <tt>http://localhost:3000/blog</tt>, the posts will be empty. This is because the table created inside the application is different from the one created within the engine. Go ahead, play around with the newly mounted engine. You&#8217;ll find that it&#8217;s the same as when it was only an engine.</p>
<h4 id="using-a-class-provided-by-the-application">4.3 Using a class provided by the application</h4>
<p>When an engine is created, it may want to use specific classes from an application to provide links between the pieces of the engine and the pieces of the application. In the case of the <tt>blorgh</tt> engine, making posts and comments have authors would make a lot of sense.</p>
<p>Usually, an application would have a <tt>User</tt> class that would provide the objects that would represent the posts&#8217; and comments&#8217; authors, but there could be a case where the application calls this class something different, such as <tt>Person</tt>. It&#8217;s because of this reason that the engine should not hardcode the associations to be exactly for a <tt>User</tt> class, but should allow for some flexibility around what the class is called.</p>
<p>To keep it simple in this case, the application will have a class called <tt>User</tt> which will represent the users of the application. It can be generated using this command:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
rails g model user name:string
</pre>
</div>
<p>The <tt>rake db:migrate</tt> command needs to be run here to ensure that our application has the <tt>users</tt> table for future use.</p>
<p>Also to keep it simple, the posts form will have a new text field called <tt>author_name_</tt> where users can elect to put their name. The engine will then take this name and create a new <tt>User</tt> object from it or find one that already has that name, and then associate the post with it.</p>
<p>First, the <tt>author_name</tt> text field needs to be added to the <tt>app/views/blorgh/posts/_form.html.erb</tt> partial inside the engine. This can be added above the <tt>title</tt> field with this code:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;div class=&quot;field&quot;&gt;
  &lt;%= f.label :author_name %&gt;&lt;br /&gt;
  &lt;%= f.text_field :author_name %&gt;
&lt;/div&gt;
</pre>
</div>
<p>The <tt>Blorgh::Post</tt> model should then have some code to convert the <tt>author_name</tt> field into an actual <tt>User</tt> object and associate it as that post&#8217;s <tt>author</tt> before the post is saved. It will also need to have an <tt>attr_accessor</tt> setup for this field so that the setter and getter methods are defined for it.</p>
<p>To do all this, you&#8217;ll need to add the <tt>attr_accessor</tt> for <tt>author_name</tt>, the association for the author and the <tt>before_save</tt> call into <tt>app/models/blorgh/post.rb</tt>. The <tt>author</tt> association will be hard-coded to the <tt>User</tt> class for the time being.</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
attr_accessor :author_name
belongs_to :author, :class_name =&gt; &quot;User&quot;

before_save :set_author

private
  def set_author
    self.author = User.find_or_create_by_name(author_name)
  end
</pre>
</div>
<p>By defining that the <tt>author</tt> association&#8217;s object is represented by the <tt>User</tt> class a link is established between the engine and the application. There needs to be a way of associating the records in the <tt>blorgh_posts</tt> table with the records in the <tt>users</tt> table. Because the association is called <tt>author</tt>, there should be an <tt>author_id</tt> column added to the <tt>blorgh_posts</tt> table.</p>
<p>To generate this new column, run this command within the engine:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails g migration add_author_id_to_blorgh_posts author_id:integer
</pre>
</div>
<div class="note"><p>Due to the migration&#8217;s name and the column specification after it, Rails will automatically know that you want to add a column to a specific table and write that into the migration for you. You don&#8217;t need to tell it any more than this.</p></div>
<p>This migration will need to be run on the application. To do that, it must first be copied using this command:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake blorgh:install:migrations
</pre>
</div>
<p>Notice here that only <em>one</em> migration was copied over here. This is because the first two migrations were copied over the first time this command was run.</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
NOTE: Migration [timestamp]_create_blorgh_posts.rb from blorgh has been skipped. Migration with the same name already exists.
  NOTE: Migration [timestamp]_create_blorgh_comments.rb from blorgh has been skipped. Migration with the same name already exists.
  Copied migration [timestamp]_add_author_id_to_blorgh_posts.rb from blorgh
</pre>
</div>
<p>Run this migration using this command:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake db:migrate
</pre>
</div>
<p>Now with all the pieces in place, an action will take place that will associate an author &#8212; represented by a record in the <tt>users</tt> table &#8212; with a post, represented by the <tt>blorgh_posts</tt> table from the engine.</p>
<p>Finally, the author&#8217;s name should be displayed on the post&#8217;s page. Add this code above the &#8220;Title&#8221; output inside <tt>app/views/blorgh/posts/show.html.erb</tt>:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;b&gt;Author:&lt;/b&gt;
  &lt;%= @post.author %&gt;
&lt;/p&gt;
</pre>
</div>
<div class="warning"><p>For posts created previously, this will break the <tt>show</tt> page for them. We recommend deleting these posts and starting again, or manually assigning an author using <tt>rails c</tt>.</p></div>
<p>By outputting <tt>@post.author</tt> using the <tt><%=</tt> tag the <tt>to_s</tt> method will be called on the object. By default, this will look quite ugly:</p>
<text>
<p>#<User:0x00000100ccb3b0></p>
</text>
<p>This is undesirable and it would be much better to have the user&#8217;s name there. To do this, add a <tt>to_s</tt> method to the <tt>User</tt> class within the application:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def to_s
  name
end
</pre>
</div>
<p>Now instead of the ugly Ruby object output the author&#8217;s name will be displayed.</p>
<h4 id="configuring-an-engine">4.4 Configuring an engine</h4>
<p>The next step is to make the class that represents a <tt>User</tt> in the application customizable for the engine. This is because, as explained before, that class may not always be <tt>User</tt>. To make this customizable, the engine will have a configuration setting called <tt>user_class</tt> that will be used to specify what the class representing users is inside the application.</p>
<p>To define this configuration setting, you should use a <tt>mattr_accessor</tt> inside the <tt>Blorgh</tt> module for the engine, located at <tt>lib/blorgh.rb</tt> inside the engine. Inside this module, put this line:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
mattr_accessor :user_class
</pre>
</div>
<p>This method works like its brothers <tt>attr_accessor</tt> and <tt>cattr_accessor</tt>, but provides a setter and getter method on the module with the specified name. To use it, it must be referenced using <tt>Blorgh.user_class</tt>.</p>
<p>The next step is switching the <tt>Blorgh::Post</tt> model over to this new setting. For the <tt>belongs_to</tt> association inside this model (<tt>app/models/blorgh/post.rb</tt>), it will now become this:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
belongs_to :author, :class_name =&gt; Blorgh.user_class
</pre>
</div>
<p>The <tt>set_author</tt> method also located in this class should also use this class:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
self.author = Blorgh.user_class.constantize.find_or_create_by_name(author_name)
</pre>
</div>
<p>To set this configuration setting within the application, an initializer should be used. By using an initializer, the configuration will be set up before the application starts and makes references to the classes of the engine which may depend on this configuration setting existing.</p>
<p>Create a new initializer at <tt>config/initializers/blorgh.rb</tt> inside the application where the <tt>blorgh</tt> engine is installed and put this content in it:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Blorgh.user_class = &quot;User&quot;
</pre>
</div>
<div class="warning"><p>It&#8217;s very important here to use the <tt>String</tt> version of the class, rather than the class itself. If you were to use the class, Rails would attempt to load that class and then reference the related table, which could lead to problems if the table wasn&#8217;t already existing. Therefore, a <tt>String</tt> should be used and then converted to a class using <tt>constantize</tt> in the engine later on.</p></div>
<p>Go ahead and try to create a new post. You will see that it works exactly in the same way as before, except this time the engine is using the configuration setting in <tt>config/initializers/blorgh.rb</tt> to learn what the class is.</p>
<p>There are now no strict dependencies on what the class is, only what the class&#8217;s <span class="caps">API</span> must be. The engine simply requires this class to define a <tt>find_or_create_by_name</tt> method which returns an object of that class to be associated with a post when it&#8217;s created.</p>
<h3 id="extending-engine-functionality">5 Extending engine functionality</h3>
<p>This section looks at overriding or adding functionality to the views, controllers and models provided by an engine.</p>
<h4 id="overriding-views">5.1 Overriding views</h4>
<p>When Rails looks for a view to render, it will first look in the <tt>app/views</tt> directory of the application. If it cannot find the view there, then it will check in the <tt>app/views</tt> directories of all engines which have this directory.</p>
<p>In the <tt>blorgh</tt> engine, there is a currently a file at <tt>app/views/blorgh/posts/index.html.erb</tt>. When the engine is asked to render the view for <tt>Blorgh::PostsController</tt>&#8217;s <tt>index</tt> action, it will first see if it can find it at <tt>app/views/blorgh/posts/index.html.erb</tt> within the application and then if it cannot it will look inside the engine.</p>
<p>By overriding this view in the application, by simply creating a new file at <tt>app/views/blorgh/posts/index.html.erb</tt>, you can completely change what this view would normally output.</p>
<p>Try this now by creating a new file at <tt>app/views/blorgh/posts/index.html.erb</tt> and put this content in it:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Posts&lt;/h1&gt;
&lt;%= link_to &quot;New Post&quot;, new_post_path %&gt;
&lt;% @posts.each do |post| %&gt;
  &lt;h2&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
  &lt;small&gt;By &lt;%= post.author %&gt;&lt;/small&gt;
  &lt;%= simple_format(post.text) %&gt;
  &lt;hr&gt;
&lt;% end %&gt;
</pre>
</div>
<p>Rather than looking like the default scaffold, the page will now look like this:</p>
<p><img src="images/engines_post_override.png" title="Engine scaffold overriden" alt="Engine scaffold overriden" /></p>
<h4 id="controllers">5.2 Controllers</h4>
<p><span class="caps">TODO</span>: Explain how to extend a controller.
<span class="caps">IDEA</span>: I like Devise&#8217;s <tt>devise :controllers => { "sessions" => "sessions" }</tt> idea. Perhaps we could incorporate that into the guide?</p>
<h4 id="models">5.3 Models</h4>
<p><span class="caps">TODO</span>: Explain how to extend models provided by an engine.</p>
<h4 id="routes">5.4 Routes</h4>
<p>Within the application, you may wish to link to some area within the engine. Due to the fact that the engine&#8217;s routes are isolated (by the <tt>isolate_namespace</tt> call within the <tt>lib/blorgh/engine.rb</tt> file), you will need to prefix these routes with the engine name. This means rather than having something such as:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= link_to &quot;Blog posts&quot;, posts_path %&gt;
</pre>
</div>
<p>It needs to be written as:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= link_to &quot;Blog posts&quot;, blorgh.posts_path %&gt;
</pre>
</div>
<p>This allows for the engine <em>and</em> the application to both have a <tt>posts_path</tt> routing helper and to not interfere with each other. You may also reference another engine&#8217;s routes from inside an engine using this same syntax.</p>
<p>If you wish to reference the application inside the engine in a similar way, use the <tt>main_app</tt> helper:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= link_to &quot;Home&quot;, main_app.root_path %&gt;
</pre>
</div>
<p><span class="caps">TODO</span>: Mention how to use assets within an engine?
<span class="caps">TODO</span>: Mention how to depend on external gems, like RedCarpet.</p>

        <h3>Feedback</h3>
        <p>
          You're encouraged to help improve the quality of this guide.
        </p>
        <p>
          If you see any typos or factual errors you are confident to
          patch, please clone <a href="https://github.com/lifo/docrails">docrails</a>
          and push the change yourself. That branch of Rails has public write access.
          Commits are still reviewed, but that happens after you've submitted your
          contribution. <a href="https://github.com/lifo/docrails">docrails</a> is
          cross-merged with master periodically.
        </p>
        <p>
          You may also find incomplete content, or stuff that is not up to date.
          Please do add any missing documentation for master. Check the
          <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a>
          for style and conventions.
        </p>
        <p>
          If for whatever reason you spot something to fix but cannot patch it yourself, please
          <a href="https://github.com/rails/rails/issues">open an issue</a>.
        </p>
        <p>And last but not least, any kind of discussion regarding Ruby on Rails
          documentation is very welcome in the <a href="http://groups.google.com/group/rubyonrails-docs">rubyonrails-docs mailing list</a>.
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0</a> License</p>
      <p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>
    </div>
  </div>

  <script type="text/javascript" src="javascripts/guides.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushRuby.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushXml.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushSql.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all()
  </script>
</body>
</html>
