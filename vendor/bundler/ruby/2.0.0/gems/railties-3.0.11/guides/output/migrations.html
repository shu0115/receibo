<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Ruby on Rails Guides: Migrations</title>

<link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" />

<link rel="stylesheet" type="text/css" href="stylesheets/fixes.css" />
</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong>More at <a href="http://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <a href="http://rubyonrails.org/">Overview</a> |
      <a href="http://rubyonrails.org/download">Download</a> |
      <a href="http://rubyonrails.org/deploy">Deploy</a> |
      <a href="https://github.com/rails/rails">Code</a> |
      <a href="http://rubyonrails.org/screencasts">Screencasts</a> |
      <a href="http://rubyonrails.org/documentation">Documentation</a> |
      <a href="http://rubyonrails.org/ecosystem">Ecosystem</a> |
      <a href="http://rubyonrails.org/community">Community</a> |
      <a href="http://weblog.rubyonrails.org/">Blog</a>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Return to home page">Guides.rubyonrails.org</a></h1>
      <p class="hide"><a href="#mainCol">Skip navigation</a>.</p>
      <ul class="nav">
        <li><a href="index.html">Home</a></li>
        <li class="index"><a href="index.html" onclick="guideMenu(); return false;" id="guidesMenu">Guides Index</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="L">
              <dt>Start Here</dt>
              <dd><a href="getting_started.html">Getting Started with Rails</a></dd>
              <dt>Models</dt>
              <dd><a href="migrations.html">Rails Database Migrations</a></dd>
              <dd><a href="active_record_validations_callbacks.html">Active Record Validations and Callbacks</a></dd>
              <dd><a href="association_basics.html">Active Record Associations</a></dd>
              <dd><a href="active_record_querying.html">Active Record Query Interface</a></dd>
              <dt>Views</dt>
              <dd><a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
              <dd><a href="form_helpers.html">Action View Form Helpers</a></dd>
              <dt>Controllers</dt>
              <dd><a href="action_controller_overview.html">Action Controller Overview</a></dd>
              <dd><a href="routing.html">Rails Routing from the Outside In</a></dd>
            </dl>
            <dl class="R">
              <dt>Digging Deeper</dt>
              <dd><a href="active_support_core_extensions.html">Active Support Core Extensions</a></dd>
              <dd><a href="i18n.html">Rails Internationalization API</a></dd>
              <dd><a href="action_mailer_basics.html">Action Mailer Basics</a></dd>
              <dd><a href="testing.html">Testing Rails Applications</a></dd>
              <dd><a href="security.html">Securing Rails Applications</a></dd>
              <dd><a href="debugging_rails_applications.html">Debugging Rails Applications</a></dd>
              <dd><a href="performance_testing.html">Performance Testing Rails Applications</a></dd>
              <dd><a href="configuring.html">Configuring Rails Applications</a></dd>
              <dd><a href="command_line.html">Rails Command Line Tools and Rake Tasks</a></dd>
              <dd><a href="caching_with_rails.html">Caching with Rails</a></dd>
              <dd><a href="asset_pipeline.html">Asset Pipeline</a></dd>

              <dt>Extending Rails</dt>
              <dd><a href="plugins.html">The Basics of Creating Rails Plugins</a></dd>
              <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
              <dd><a href="generators.html">Creating and Customizing Rails Generators</a></dd>

              <dt>Contributing to Ruby on Rails</dt>
              <dd><a href="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</a></dd>
              <dd><a href="api_documentation_guidelines.html">API Documentation Guidelines</a></dd>
              <dd><a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a></dd>

              <dt>Release Notes</dt>
              <dd><a href="3_1_release_notes.html">Ruby on Rails 3.1 Release Notes</a></dd>
              <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes</a></dd>
              <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes</a></dd>
              <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes</a></dd>
            </dl>
          </div>
        </li>
        <li><a href="contributing_to_ruby_on_rails.html">Contribute</a></li>
        <li><a href="credits.html">Credits</a></li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>Migrations</h2>
<p>Migrations are a convenient way for you to alter your database in a structured and organized manner. You could edit fragments of <span class="caps">SQL</span> by hand but you would then be responsible for telling other developers that they need to go and run them. You&#8217;d also have to keep track of which changes need to be run against the production machines next time you deploy.</p>
<p>Active Record tracks which migrations have already been run so all you have to do is update your source and run <tt>rake db:migrate</tt>. Active Record will work out which migrations should be run. It will also update your <tt>db/schema.rb</tt> file to match the structure of your database.</p>
<p>Migrations also allow you to describe these transformations using Ruby. The great thing about this is that (like most of Active Record&#8217;s functionality) it is database independent: you don&#8217;t need to worry about the precise syntax of <tt>CREATE TABLE</tt> any more than you worry about variations on <tt>SELECT *</tt> (you can drop down to raw <span class="caps">SQL</span> for database specific features). For example you could use SQLite3 in development, but MySQL in production.</p>
<p>You&#8217;ll learn all about migrations including:</p>
<ul>
	<li>The generators you can use to create them</li>
	<li>The methods Active Record provides to manipulate your database</li>
	<li>The Rake tasks that manipulate them</li>
	<li>How they relate to <tt>schema.rb</tt></li>
</ul>

            <div id="subCol">
        <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
        <ol class="chapters">
<li><a href="#anatomy-of-a-migration">Anatomy of a Migration</a><ul><li><a href="#migrations-are-classes">Migrations are Classes</a></li> <li><a href="#what-s-in-a-name">What&#8217;s in a Name</a></li> <li><a href="#changing-migrations">Changing Migrations</a></li> <li><a href="#supported-types">Supported Types</a></li></ul></li><li><a href="#creating-a-migration">Creating a Migration</a><ul><li><a href="#creating-a-model">Creating a Model</a></li> <li><a href="#creating-a-standalone-migration">Creating a Standalone Migration</a></li></ul></li><li><a href="#writing-a-migration">Writing a Migration</a><ul><li><a href="#creating-a-table">Creating a Table</a></li> <li><a href="#changing-tables">Changing Tables</a></li> <li><a href="#special-helpers">Special Helpers</a></li> <li><a href="#writing-your-change-method">Writing Your <tt>change</tt> Method</a></li> <li><a href="#writing-your-down-method">Writing Your <tt>down</tt> Method</a></li></ul></li><li><a href="#running-migrations">Running Migrations</a><ul><li><a href="#rolling-back">Rolling Back</a></li> <li><a href="#being-specific">Being Specific</a></li> <li><a href="#being-talkative">Being Talkative</a></li></ul></li><li><a href="#using-models-in-your-migrations">Using Models in Your Migrations</a></li><li><a href="#schema-dumping-and-you">Schema Dumping and You</a><ul><li><a href="#what-are-schema-files-for">What are Schema Files for?</a></li> <li><a href="#types-of-schema-dumps">Types of Schema Dumps</a></li> <li><a href="#schema-dumps-and-source-control">Schema Dumps and Source Control</a></li></ul></li><li><a href="#active-record-and-referential-integrity">Active Record and Referential Integrity</a></li></ol></div>
    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="anatomy-of-a-migration">1 Anatomy of a Migration</h3>
<p>Before we dive into the details of a migration, here are a few examples of the sorts of things you can do:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateProducts &lt; ActiveRecord::Migration
  def up
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end

  def down
    drop_table :products
  end
end
</pre>
</div>
<p>This migration adds a table called <tt>products</tt> with a string column called <tt>name</tt> and a text column called <tt>description</tt>. A primary key column called <tt>id</tt> will also be added, however since this is the default we do not need to ask for this. The timestamp columns <tt>created_at</tt> and <tt>updated_at</tt> which Active Record populates automatically will also be added. Reversing this migration is as simple as dropping the table.</p>
<p>Migrations are not limited to changing the schema. You can also use them to fix bad data in the database or populate new fields:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class AddReceiveNewsletterToUsers &lt; ActiveRecord::Migration
  def up
    change_table :users do |t|
      t.boolean :receive_newsletter, :default =&gt; false
    end
    User.update_all [&quot;receive_newsletter = ?&quot;, true]
  end

  def down
    remove_column :users, :receive_newsletter
  end
end
</pre>
</div>
<div class="note"><p>Some <a href="#using-models-in-your-migrations">caveats</a> apply to using models in your migrations.</p></div>
<p>This migration adds a <tt>receive_newsletter</tt> column to the <tt>users</tt> table. We want it to default to <tt>false</tt> for new users, but existing users are considered
to have already opted in, so we use the User model to set the flag to <tt>true</tt> for existing users.</p>
<p>Rails 3.1 makes migrations smarter by providing a new <tt>change</tt> method. This method is preferred for writing constructive migrations (adding columns or tables). The migration knows how to migrate your database and reverse it when the migration is rolled back without the need to write a separate <tt>down</tt> method.</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateProducts &lt; ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
</pre>
</div>
<h4 id="migrations-are-classes">1.1 Migrations are Classes</h4>
<p>A migration is a subclass of <tt>ActiveRecord::Migration</tt> that implements two methods: <tt>up</tt> (perform the required transformations) and <tt>down</tt> (revert them).</p>
<p>Active Record provides methods that perform common data definition tasks in a database independent way (you&#8217;ll read about them in detail later):</p>
<ul>
	<li><tt>create_table</tt></li>
	<li><tt>change_table</tt></li>
	<li><tt>drop_table</tt></li>
	<li><tt>add_column</tt></li>
	<li><tt>change_column</tt></li>
	<li><tt>rename_column</tt></li>
	<li><tt>remove_column</tt></li>
	<li><tt>add_index</tt></li>
	<li><tt>remove_index</tt></li>
</ul>
<p>If you need to perform tasks specific to your database (for example create a <a href="#active-record-and-referential-integrity">foreign key</a> constraint) then the <tt>execute</tt> method allows you to execute arbitrary <span class="caps">SQL</span>. A migration is just a regular Ruby class so you&#8217;re not limited to these functions. For example after adding a column you could write code to set the value of that column for existing records (if necessary using your models).</p>
<p>On databases that support transactions with statements that change the schema (such as PostgreSQL or SQLite3), migrations are wrapped in a transaction. If the database does not support this (for example MySQL) then when a migration fails the parts of it that succeeded will not be rolled back. You will have to unpick the changes that were made by hand.</p>
<h4 id="what-s-in-a-name">1.2 What&#8217;s in a Name</h4>
<p>Migrations are stored in files in <tt>db/migrate</tt>, one for each migration class. The name of the file is of the form <tt>YYYYMMDDHHMMSS_create_products.rb</tt>, that is to say a <span class="caps">UTC</span> timestamp identifying the migration followed by an underscore followed by the name of the migration. The name of the migration class (CamelCased version) should match the latter part of the file name. For example <tt>20080906120000_create_products.rb</tt> should define class <tt>CreateProducts</tt> and <tt>20080906120001_add_details_to_products.rb</tt> should define <tt>AddDetailsToProducts</tt>. If you do feel the need to change the file name then you <em>have to</em> update the name of the class inside or Rails will complain about a missing class.</p>
<p>Internally Rails only uses the migration&#8217;s number (the timestamp) to identify them. Prior to Rails 2.1 the migration number started at 1 and was incremented each time a migration was generated. With multiple developers it was easy for these to clash requiring you to rollback migrations and renumber them. With Rails 2.1 this is largely avoided by using the creation time of the migration to identify them. You can revert to the old numbering scheme by adding the following line to <tt>config/application.rb</tt>.</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
config.active_record.timestamped_migrations = false
</pre>
</div>
<p>The combination of timestamps and recording which migrations have been run allows Rails to handle common situations that occur with multiple developers.</p>
<p>For example Alice adds migrations <tt>20080906120000</tt> and <tt>20080906123000</tt> and Bob adds <tt>20080906124500</tt> and runs it. Alice finishes her changes and checks in her migrations and Bob pulls down the latest changes. Rails knows that it has not run Alice&#8217;s two migrations so <tt>rake db:migrate</tt> would run them (even though Bob&#8217;s migration with a later timestamp has been run), and similarly migrating down would not run their <tt>down</tt> methods.</p>
<p>Of course this is no substitution for communication within the team. For example, if Alice&#8217;s migration removed a table that Bob&#8217;s migration assumed to exist, then trouble would certainly strike.</p>
<h4 id="changing-migrations">1.3 Changing Migrations</h4>
<p>Occasionally you will make a mistake when writing a migration. If you have already run the migration then you cannot just edit the migration and run the migration again: Rails thinks it has already run the migration and so will do nothing when you run <tt>rake db:migrate</tt>. You must rollback the migration (for example with <tt>rake db:rollback</tt>), edit your migration and then run <tt>rake db:migrate</tt> to run the corrected version.</p>
<p>In general editing existing migrations is not a good idea: you will be creating extra work for yourself and your co-workers and cause major headaches if the existing version of the migration has already been run on production machines. Instead, you should write a new migration that performs the changes you require. Editing a freshly generated migration that has not yet been committed to source control (or, more generally, which has not been propagated beyond your development machine) is relatively harmless.</p>
<h4 id="supported-types">1.4 Supported Types</h4>
<p>Active Record supports the following types:</p>
<ul>
	<li><tt>:primary_key</tt></li>
	<li><tt>:string</tt></li>
	<li><tt>:text</tt></li>
	<li><tt>:integer</tt></li>
	<li><tt>:float</tt></li>
	<li><tt>:decimal</tt></li>
	<li><tt>:datetime</tt></li>
	<li><tt>:timestamp</tt></li>
	<li><tt>:time</tt></li>
	<li><tt>:date</tt></li>
	<li><tt>:binary</tt></li>
	<li><tt>:boolean</tt></li>
</ul>
<p>These will be mapped onto an appropriate underlying database type. For example, with MySQL the type <tt>:string</tt> is mapped to <tt>VARCHAR(255)</tt>. You can create columns of types not supported by Active Record when using the non-sexy syntax, for example</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
create_table :products do |t|
  t.column :name, 'polygon', :null =&gt; false
end
</pre>
</div>
<p>This may however hinder portability to other databases.</p>
<h3 id="creating-a-migration">2 Creating a Migration</h3>
<h4 id="creating-a-model">2.1 Creating a Model</h4>
<p>The model and scaffold generators will create migrations appropriate for adding a new model. This migration will already contain instructions for creating the relevant table. If you tell Rails what columns you want, then statements for adding these columns will also be created. For example, running</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate model Product name:string description:text
</pre>
</div>
<p>will create a migration that looks like this</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateProducts &lt; ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
</pre>
</div>
<p>You can append as many column name/type pairs as you want. By default <tt>t.timestamps</tt> (which creates the <tt>updated_at</tt> and <tt>created_at</tt> columns that
are automatically populated by Active Record) will be added for you.</p>
<h4 id="creating-a-standalone-migration">2.2 Creating a Standalone Migration</h4>
<p>If you are creating migrations for other purposes (for example to add a column to an existing table) then you can use the migration generator:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate migration AddPartNumberToProducts
</pre>
</div>
<p>This will create an empty but appropriately named migration:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class AddPartNumberToProducts &lt; ActiveRecord::Migration
  def change
  end
end
</pre>
</div>
<p>If the migration name is of the form &#8220;AddXXXToYYY&#8221; or &#8220;RemoveXXXFromYYY&#8221; and is followed by a list of column names and types then a migration containing the appropriate <tt>add_column</tt> and <tt>remove_column</tt> statements will be created.</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate migration AddPartNumberToProducts part_number:string
</pre>
</div>
<p>will generate</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class AddPartNumberToProducts &lt; ActiveRecord::Migration
  def change
    add_column :products, :part_number, :string
  end
end
</pre>
</div>
<p>Similarly,</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate migration RemovePartNumberFromProducts part_number:string
</pre>
</div>
<p>generates</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class RemovePartNumberFromProducts &lt; ActiveRecord::Migration
  def up
    remove_column :products, :part_number
  end

  def down
    add_column :products, :part_number, :string
  end
end
</pre>
</div>
<p>You are not limited to one magically generated column, for example</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate migration AddDetailsToProducts part_number:string price:decimal
</pre>
</div>
<p>generates</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class AddDetailsToProducts &lt; ActiveRecord::Migration
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end
</pre>
</div>
<p>As always, what has been generated for you is just a starting point. You can add or remove from it as you see fit.</p>
<div class="note"><p>The generated migration file for destructive migrations will still be old-style using the <tt>up</tt> and <tt>down</tt> methods. This is because Rails doesn&#8217;t know the original data types defined when you made the original changes.</p></div>
<h3 id="writing-a-migration">3 Writing a Migration</h3>
<p>Once you have created your migration using one of the generators it&#8217;s time to get to work!</p>
<h4 id="creating-a-table">3.1 Creating a Table</h4>
<p>Migration method <tt>create_table</tt> will be one of your workhorses. A typical use would be</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
create_table :products do |t|
  t.string :name
end
</pre>
</div>
<p>which creates a <tt>products</tt> table with a column called <tt>name</tt> (and as discussed below, an implicit <tt>id</tt> column).</p>
<p>The object yielded to the block allows you to create columns on the table. There are two ways of doing it. The first (traditional) form looks like</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
create_table :products do |t|
  t.column :name, :string, :null =&gt; false
end
</pre>
</div>
<p>The second form, the so called &#8220;sexy&#8221; migration, drops the somewhat redundant <tt>column</tt> method. Instead, the <tt>string</tt>, <tt>integer</tt>, etc. methods create a column of that type. Subsequent parameters are the same.</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
create_table :products do |t|
  t.string :name, :null =&gt; false
end
</pre>
</div>
<p>By default, <tt>create_table</tt> will create a primary key called <tt>id</tt>. You can change the name of the primary key with the <tt>:primary_key</tt> option (don&#8217;t forget to update the corresponding model) or, if you don&#8217;t want a primary key at all (for example for a <span class="caps">HABTM</span> join table), you can pass the option <tt>:id => false</tt>. If you need to pass database specific options you can place an <span class="caps">SQL</span> fragment in the <tt>:options</tt> option. For example,</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
create_table :products, :options =&gt; &quot;ENGINE=BLACKHOLE&quot; do |t|
  t.string :name, :null =&gt; false
end
</pre>
</div>
<p>will append <tt>ENGINE=BLACKHOLE</tt> to the <span class="caps">SQL</span> statement used to create the table (when using MySQL, the default is <tt>ENGINE=InnoDB</tt>).</p>
<h4 id="changing-tables">3.2 Changing Tables</h4>
<p>A close cousin of <tt>create_table</tt> is <tt>change_table</tt>, used for changing existing tables. It is used in a similar fashion to <tt>create_table</tt> but the object yielded to the block knows more tricks. For example</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
</pre>
</div>
<p>removes the <tt>description</tt> and <tt>name</tt> columns, creates a <tt>part_number</tt> column and adds an index on it. Finally it renames the <tt>upccode</tt> column. This is the same as doing</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
remove_column :products, :description
remove_column :products, :name
add_column :products, :part_number, :string
add_index :products, :part_number
rename_column :products, :upccode, :upc_code
</pre>
</div>
<p>You don&#8217;t have to keep repeating the table name and it groups all the statements related to modifying one particular table. The individual transformation names are also shorter, for example <tt>remove_column</tt> becomes just <tt>remove</tt> and <tt>add_index</tt> becomes just <tt>index</tt>.</p>
<h4 id="special-helpers">3.3 Special Helpers</h4>
<p>Active Record provides some shortcuts for common functionality. It is for example very common to add both the <tt>created_at</tt> and <tt>updated_at</tt> columns and so there is a method that does exactly that:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
create_table :products do |t|
  t.timestamps
end
</pre>
</div>
<p>will create a new products table with those two columns (plus the <tt>id</tt> column) whereas</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
change_table :products do |t|
  t.timestamps
end
</pre>
</div>
<p>adds those columns to an existing table.</p>
<p>The other helper is called <tt>references</tt> (also available as <tt>belongs_to</tt>). In its simplest form it just adds some readability</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
create_table :products do |t|
  t.references :category
end
</pre>
</div>
<p>will create a <tt>category_id</tt> column of the appropriate type. Note that you pass the model name, not the column name. Active Record adds the <tt>_id</tt> for you. If you have polymorphic <tt>belongs_to</tt> associations then <tt>references</tt> will add both of the columns required:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
create_table :products do |t|
  t.references :attachment, :polymorphic =&gt; {:default =&gt; 'Photo'}
end
</pre>
</div>
<p>will add an <tt>attachment_id</tt> column and a string <tt>attachment_type</tt> column with a default value of &#8216;Photo&#8217;.</p>
<div class="note"><p>The <tt>references</tt> helper does not actually create foreign key constraints for you. You will need to use <tt>execute</tt> or a plugin that adds <a href="#active-record-and-referential-integrity">foreign key support</a>.</p></div>
<p>If the helpers provided by Active Record aren&#8217;t enough you can use the <tt>execute</tt> method to execute arbitrary <span class="caps">SQL</span>.</p>
<p>For more details and examples of individual methods, check the <span class="caps">API</span> documentation, in particular the documentation for <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html"><tt>ActiveRecord::ConnectionAdapters::SchemaStatements</tt></a> (which provides the methods available in the <tt>up</tt> and <tt>down</tt> methods), <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html"><tt>ActiveRecord::ConnectionAdapters::TableDefinition</tt></a> (which provides the methods available on the object yielded by <tt>create_table</tt>) and <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html"><tt>ActiveRecord::ConnectionAdapters::Table</tt></a> (which provides the methods available on the object yielded by <tt>change_table</tt>).</p>
<h4 id="writing-your-change-method">3.4 Writing Your <tt>change</tt> Method</h4>
<p>The <tt>change</tt> method removes the need to write both <tt>up</tt> and <tt>down</tt> methods in those cases that Rails know how to revert the changes automatically. Currently, the <tt>change</tt> method supports only these migration definitions:</p>
<ul>
	<li><tt>add_column</tt></li>
	<li><tt>add_index</tt></li>
	<li><tt>add_timestamps</tt></li>
	<li><tt>create_table</tt></li>
	<li><tt>remove_timestamps</tt></li>
	<li><tt>rename_column</tt></li>
	<li><tt>rename_index</tt></li>
	<li><tt>rename_table</tt></li>
</ul>
<p>If you&#8217;re going to use other methods, you&#8217;ll have to write the <tt>up</tt> and <tt>down</tt> methods normally.</p>
<h4 id="writing-your-down-method">3.5 Writing Your <tt>down</tt> Method</h4>
<p>The <tt>down</tt> method of your migration should revert the transformations done by the <tt>up</tt> method. In other words, the database schema should be unchanged if you do an <tt>up</tt> followed by a <tt>down</tt>. For example, if you create a table in the <tt>up</tt> method, you should drop it in the <tt>down</tt> method. It is wise to reverse the transformations in precisely the reverse order they were made in the <tt>up</tt> method. For example,</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ExampleMigration &lt; ActiveRecord::Migration

  def up
    create_table :products do |t|
      t.references :category
    end
    #add a foreign key
    execute &lt;&lt;-SQL
      ALTER TABLE products
        ADD CONSTRAINT fk_products_categories
        FOREIGN KEY (category_id)
        REFERENCES categories(id)
    SQL

    add_column :users, :home_page_url, :string

    rename_column :users, :email, :email_address
  end

  def down
    rename_column :users, :email_address, :email
    remove_column :users, :home_page_url
    execute &quot;ALTER TABLE products DROP FOREIGN KEY fk_products_categories&quot;
    drop_table :products
  end
end
</pre>
</div>
<p>Sometimes your migration will do something which is just plain irreversible; for example, it might destroy some data. In such cases, you can raise <tt>ActiveRecord::IrreversibleMigration</tt> from your <tt>down</tt> method. If someone tries to revert your migration, an error message will be displayed saying that it can&#8217;t be done.</p>
<h3 id="running-migrations">4 Running Migrations</h3>
<p>Rails provides a set of rake tasks to work with migrations which boil down to running certain sets of migrations. The very first migration related rake task you will use will probably be <tt>db:migrate</tt>. In its most basic form it just runs the <tt>up</tt> method for all the migrations that have not yet been run. If there are no such migrations, it exits.</p>
<p>Note that running the <tt>db:migrate</tt> also invokes the <tt>db:schema:dump</tt> task, which will update your db/schema.rb file to match the structure of your database.</p>
<p>If you specify a target version, Active Record will run the required migrations (up or down) until it has reached the specified version. The
version is the numerical prefix on the migration&#8217;s filename. For example, to migrate to version 20080906120000 run</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake db:migrate VERSION=20080906120000
</pre>
</div>
<p>If version 20080906120000 is greater than the current version (i.e., it is migrating upwards), this will run the <tt>up</tt> method on all migrations up to and including 20080906120000. If migrating downwards, this will run the <tt>down</tt> method on all the migrations down to, but not including, 20080906120000.</p>
<h4 id="rolling-back">4.1 Rolling Back</h4>
<p>A common task is to rollback the last migration, for example if you made a mistake in it and wish to correct it. Rather than tracking down the version number associated with the previous migration you can run</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake db:rollback
</pre>
</div>
<p>This will run the <tt>down</tt> method from the latest migration. If you need to undo several migrations you can provide a <tt>STEP</tt> parameter:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake db:rollback STEP=3
</pre>
</div>
<p>will run the <tt>down</tt> method from the last 3 migrations.</p>
<p>The <tt>db:migrate:redo</tt> task is a shortcut for doing a rollback and then migrating back up again. As with the <tt>db:rollback</tt> task, you can use the <tt>STEP</tt> parameter if you need to go more than one version back, for example</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake db:migrate:redo STEP=3
</pre>
</div>
<p>Neither of these Rake tasks do anything you could not do with <tt>db:migrate</tt>. They are simply more convenient, since you do not need to explicitly specify the version to migrate to.</p>
<p>Lastly, the <tt>db:reset</tt> task will drop the database, recreate it and load the current schema into it.</p>
<div class="note"><p>This is not the same as running all the migrations &#8211; see the section on <a href="#schema-dumping-and-you">schema.rb</a>.</p></div>
<h4 id="being-specific">4.2 Being Specific</h4>
<p>If you need to run a specific migration up or down, the <tt>db:migrate:up</tt> and <tt>db:migrate:down</tt> tasks will do that. Just specify the appropriate version and the corresponding migration will have its <tt>up</tt> or <tt>down</tt> method invoked, for example,</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rake db:migrate:up VERSION=20080906120000
</pre>
</div>
<p>will run the <tt>up</tt> method from the 20080906120000 migration. These tasks check whether the migration has already run, so for example <tt>db:migrate:up VERSION=20080906120000</tt> will do nothing if Active Record believes that 20080906120000 has already been run.</p>
<h4 id="being-talkative">4.3 Being Talkative</h4>
<p>By default migrations tell you exactly what they&#8217;re doing and how long it took. A migration creating a table and adding an index might produce output like this</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
20080906170109 CreateProducts: migrating
-- create_table(:products)
   -&gt; 0.0021s
-- add_index(:products, :name)
   -&gt; 0.0026s
20080906170109 CreateProducts: migrated (0.0059s)
</pre>
</div>
<p>Several methods are provided that allow you to control all this:</p>
<ul>
	<li><tt>suppress_messages</tt> takes a block as an argument and suppresses any output generated by the block.</li>
	<li><tt>say</tt> takes a message argument and outputs it as is. A second boolean argument can be passed to specify whether to indent or not.</li>
	<li><tt>say_with_time</tt> outputs text along with how long it took to run its block. If the block returns an integer it assumes it is the number of rows affected.</li>
</ul>
<p>For example, this migration</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateProducts &lt; ActiveRecord::Migration
  def change
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end
    say &quot;Created a table&quot;
    suppress_messages {add_index :products, :name}
    say &quot;and an index!&quot;, true
    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end
end
</pre>
</div>
<p>generates the following output</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
20080906170109 CreateProducts: migrating
  Created a table
   -&gt; and an index!
  Waiting for a while
   -&gt; 10.0001s
   -&gt; 250 rows
20080906170109 CreateProducts: migrated (10.0097s)
</pre>
</div>
<p>If you just want Active Record to shut up, then running <tt>rake db:migrate VERBOSE=false</tt> will suppress all output.</p>
<h3 id="using-models-in-your-migrations">5 Using Models in Your Migrations</h3>
<p>When creating or updating data in a migration it is often tempting to use one of your models. After all, they exist to provide easy access to the underlying data. This can be done, but some caution should be observed.</p>
<p>For example, problems occur when the model uses database columns which are (1) not currently in the database and (2) will be created by this or a subsequent migration.</p>
<p>Consider this example, where Alice and Bob are working on the same code base which contains a <tt>Product</tt> model:</p>
<p>Bob goes on vacation.</p>
<p>Alice creates a migration for the <tt>products</tt> table which adds a new column and initializes it.
She also adds a validation to the <tt>Product</tt> model for the new column.</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# db/migrate/20100513121110_add_flag_to_product.rb

class AddFlagToProduct &lt; ActiveRecord::Migration
  def change
    add_column :products, :flag, :int
    Product.all.each { |f| f.update_attributes!(:flag =&gt; 'false') }
  end
end
</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# app/model/product.rb

class Product &lt; ActiveRecord::Base
  validates :flag, :presence =&gt; true
end
</pre>
</div>
<p>Alice adds a second migration which adds and initializes another column to the <tt>products</tt> table and also adds a validation to the <tt>Product</tt> model for the new column.</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# db/migrate/20100515121110_add_fuzz_to_product.rb

class AddFuzzToProduct &lt; ActiveRecord::Migration
  def change
    add_column :products, :fuzz, :string
    Product.all.each { |f| f.update_attributes! :fuzz =&gt; 'fuzzy' }
  end
end
</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# app/model/product.rb

class Product &lt; ActiveRecord::Base
  validates :flag, :fuzz, :presence =&gt; true
end
</pre>
</div>
<p>Both migrations work for Alice.</p>
<p>Bob comes back from vacation and:</p>
<ol>
	<li>updates the source &#8211; which contains both migrations and the latests version of the Product model.</li>
	<li>runs outstanding migrations with <tt>rake db:migrate</tt>, which includes the one that updates the <tt>Product</tt> model.</li>
</ol>
<p>The migration crashes because when the model attempts to save, it tries to validate the second added column, which is not in the database when the <em>first</em> migration runs:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
rake aborted!
An error has occurred, this and all later migrations canceled:

undefined method `fuzz' for #&lt;Product:0x000001049b14a0&gt;
</pre>
</div>
<p>A fix for this is to create a local model within the migration. This keeps rails from running the validations, so that the migrations run to completion.</p>
<p>When using a faux model, it&#8217;s a good idea to call <tt>Product.reset_column_information</tt> to refresh the <tt>ActiveRecord</tt> cache for the <tt>Product</tt> model prior to updating data in the database.</p>
<p>If Alice had done this instead, there would have been no problem:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# db/migrate/20100513121110_add_flag_to_product.rb

class AddFlagToProduct &lt; ActiveRecord::Migration
  class Product &lt; ActiveRecord::Base
  end

  def change
    add_column :products, :flag, :int
    Product.reset_column_information
    Product.all.each { |f| f.update_attributes!(:flag =&gt; false) }
  end
end
</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# db/migrate/20100515121110_add_fuzz_to_product.rb

class AddFuzzToProduct &lt; ActiveRecord::Migration
  class Product &lt; ActiveRecord::Base
  end
  def change
    add_column :products, :fuzz, :string
    Product.reset_column_information
    Product.all.each { |f| f.update_attributes! :fuzz =&gt; 'fuzzy' }
  end
end
</pre>
</div>
<h3 id="schema-dumping-and-you">6 Schema Dumping and You</h3>
<h4 id="what-are-schema-files-for">6.1 What are Schema Files for?</h4>
<p>Migrations, mighty as they may be, are not the authoritative source for your database schema. That role falls to either <tt>db/schema.rb</tt> or an <span class="caps">SQL</span> file which Active Record generates by examining the database. They are not designed to be edited, they just represent the current state of the database.</p>
<p>There is no need (and it is error prone) to deploy a new instance of an app by replaying the entire migration history. It is much simpler and faster to just load into the database a description of the current schema.</p>
<p>For example, this is how the test database is created: the current development database is dumped (either to <tt>db/schema.rb</tt> or <tt>db/development.sql</tt>) and then loaded into the test database.</p>
<p>Schema files are also useful if you want a quick look at what attributes an Active Record object has. This information is not in the model&#8217;s code and is frequently spread across several migrations, but is summed up in the schema file. The <a href="https://github.com/ctran/annotate_models">annotate_models</a> gem automatically adds and updates comments at the top of each model summarizing the schema if you desire that functionality.</p>
<h4 id="types-of-schema-dumps">6.2 Types of Schema Dumps</h4>
<p>There are two ways to dump the schema. This is set in <tt>config/application.rb</tt> by the <tt>config.active_record.schema_format</tt> setting, which may be either <tt>:sql</tt> or <tt>:ruby</tt>.</p>
<p>If <tt>:ruby</tt> is selected then the schema is stored in <tt>db/schema.rb</tt>. If you look at this file you&#8217;ll find that it looks an awful lot like one very big migration:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
ActiveRecord::Schema.define(:version =&gt; 20080906171750) do
  create_table &quot;authors&quot;, :force =&gt; true do |t|
    t.string   &quot;name&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
  end

  create_table &quot;products&quot;, :force =&gt; true do |t|
    t.string   &quot;name&quot;
    t.text     &quot;description&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
    t.string   &quot;part_number&quot;
  end
end
</pre>
</div>
<p>In many ways this is exactly what it is. This file is created by inspecting the database and expressing its structure using <tt>create_table</tt>, <tt>add_index</tt>, and so on. Because this is database-independent, it could be loaded into any database that Active Record supports. This could be very useful if you were to distribute an application that is able to run against multiple databases.</p>
<p>There is however a trade-off: <tt>db/schema.rb</tt> cannot express database specific items such as foreign key constraints, triggers, or stored procedures. While in a migration you can execute custom <span class="caps">SQL</span> statements, the schema dumper cannot reconstitute those statements from the database. If you are using features like this, then you should set the schema format to <tt>:sql</tt>.</p>
<p>Instead of using Active Record&#8217;s schema dumper, the database&#8217;s structure will be dumped using a tool specific to the database (via the <tt>db:structure:dump</tt> Rake task) into <tt>db/#{Rails.env}_structure.sql</tt>. For example, for the PostgreSQL <span class="caps">RDBMS</span>, the <tt>pg_dump</tt> utility is used. For MySQL, this file will contain the output of <tt>SHOW CREATE TABLE</tt> for the various tables. Loading these schemas is simply a question of executing the <span class="caps">SQL</span> statements they contain. By definition, this will create a perfect copy of the database&#8217;s structure. Using the <tt>:sql</tt> schema format will, however, prevent loading the schema into a <span class="caps">RDBMS</span> other than the one used to create it.</p>
<h4 id="schema-dumps-and-source-control">6.3 Schema Dumps and Source Control</h4>
<p>Because schema dumps are the authoritative source for your database schema, it is strongly recommended that you check them into source control.</p>
<h3 id="active-record-and-referential-integrity">7 Active Record and Referential Integrity</h3>
<p>The Active Record way claims that intelligence belongs in your models, not in the database. As such, features such as triggers or foreign key constraints, which push some of that intelligence back into the database, are not heavily used.</p>
<p>Validations such as <tt>validates :foreign_key, :uniqueness => true</tt> are one way in which models can enforce data integrity. The <tt>:dependent</tt> option on associations allows models to automatically destroy child objects when the parent is destroyed. Like anything which operates at the application level, these cannot guarantee referential integrity and so some people augment them with foreign key constraints.</p>
<p>Although Active Record does not provide any tools for working directly with such features, the <tt>execute</tt> method can be used to execute arbitrary <span class="caps">SQL</span>. There are also a number of plugins such as <a href="https://github.com/harukizaemon/redhillonrails/tree/master/foreign_key_migrations/">foreign_key_migrations</a> which add foreign key support to Active Record (including support for dumping foreign keys in <tt>db/schema.rb</tt>).</p>

        <h3>Feedback</h3>
        <p>
          You're encouraged to help improve the quality of this guide.
        </p>
        <p>
          If you see any typos or factual errors you are confident to
          patch, please clone <a href="https://github.com/lifo/docrails">docrails</a>
          and push the change yourself. That branch of Rails has public write access.
          Commits are still reviewed, but that happens after you've submitted your
          contribution. <a href="https://github.com/lifo/docrails">docrails</a> is
          cross-merged with master periodically.
        </p>
        <p>
          You may also find incomplete content, or stuff that is not up to date.
          Please do add any missing documentation for master. Check the
          <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a>
          for style and conventions.
        </p>
        <p>
          If for whatever reason you spot something to fix but cannot patch it yourself, please
          <a href="https://github.com/rails/rails/issues">open an issue</a>.
        </p>
        <p>And last but not least, any kind of discussion regarding Ruby on Rails
          documentation is very welcome in the <a href="http://groups.google.com/group/rubyonrails-docs">rubyonrails-docs mailing list</a>.
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0</a> License</p>
      <p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>
    </div>
  </div>

  <script type="text/javascript" src="javascripts/guides.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushRuby.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushXml.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushSql.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all()
  </script>
</body>
</html>
