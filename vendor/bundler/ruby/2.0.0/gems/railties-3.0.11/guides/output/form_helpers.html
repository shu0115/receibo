<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Ruby on Rails Guides: Rails Form helpers</title>

<link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" />

<link rel="stylesheet" type="text/css" href="stylesheets/fixes.css" />
</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong>More at <a href="http://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <a href="http://rubyonrails.org/">Overview</a> |
      <a href="http://rubyonrails.org/download">Download</a> |
      <a href="http://rubyonrails.org/deploy">Deploy</a> |
      <a href="https://github.com/rails/rails">Code</a> |
      <a href="http://rubyonrails.org/screencasts">Screencasts</a> |
      <a href="http://rubyonrails.org/documentation">Documentation</a> |
      <a href="http://rubyonrails.org/ecosystem">Ecosystem</a> |
      <a href="http://rubyonrails.org/community">Community</a> |
      <a href="http://weblog.rubyonrails.org/">Blog</a>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Return to home page">Guides.rubyonrails.org</a></h1>
      <p class="hide"><a href="#mainCol">Skip navigation</a>.</p>
      <ul class="nav">
        <li><a href="index.html">Home</a></li>
        <li class="index"><a href="index.html" onclick="guideMenu(); return false;" id="guidesMenu">Guides Index</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="L">
              <dt>Start Here</dt>
              <dd><a href="getting_started.html">Getting Started with Rails</a></dd>
              <dt>Models</dt>
              <dd><a href="migrations.html">Rails Database Migrations</a></dd>
              <dd><a href="active_record_validations_callbacks.html">Active Record Validations and Callbacks</a></dd>
              <dd><a href="association_basics.html">Active Record Associations</a></dd>
              <dd><a href="active_record_querying.html">Active Record Query Interface</a></dd>
              <dt>Views</dt>
              <dd><a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
              <dd><a href="form_helpers.html">Action View Form Helpers</a></dd>
              <dt>Controllers</dt>
              <dd><a href="action_controller_overview.html">Action Controller Overview</a></dd>
              <dd><a href="routing.html">Rails Routing from the Outside In</a></dd>
            </dl>
            <dl class="R">
              <dt>Digging Deeper</dt>
              <dd><a href="active_support_core_extensions.html">Active Support Core Extensions</a></dd>
              <dd><a href="i18n.html">Rails Internationalization API</a></dd>
              <dd><a href="action_mailer_basics.html">Action Mailer Basics</a></dd>
              <dd><a href="testing.html">Testing Rails Applications</a></dd>
              <dd><a href="security.html">Securing Rails Applications</a></dd>
              <dd><a href="debugging_rails_applications.html">Debugging Rails Applications</a></dd>
              <dd><a href="performance_testing.html">Performance Testing Rails Applications</a></dd>
              <dd><a href="configuring.html">Configuring Rails Applications</a></dd>
              <dd><a href="command_line.html">Rails Command Line Tools and Rake Tasks</a></dd>
              <dd><a href="caching_with_rails.html">Caching with Rails</a></dd>
              <dd><a href="asset_pipeline.html">Asset Pipeline</a></dd>

              <dt>Extending Rails</dt>
              <dd><a href="plugins.html">The Basics of Creating Rails Plugins</a></dd>
              <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
              <dd><a href="generators.html">Creating and Customizing Rails Generators</a></dd>

              <dt>Contributing to Ruby on Rails</dt>
              <dd><a href="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</a></dd>
              <dd><a href="api_documentation_guidelines.html">API Documentation Guidelines</a></dd>
              <dd><a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a></dd>

              <dt>Release Notes</dt>
              <dd><a href="3_1_release_notes.html">Ruby on Rails 3.1 Release Notes</a></dd>
              <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes</a></dd>
              <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes</a></dd>
              <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes</a></dd>
            </dl>
          </div>
        </li>
        <li><a href="contributing_to_ruby_on_rails.html">Contribute</a></li>
        <li><a href="credits.html">Credits</a></li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>Rails Form helpers</h2>
<p>Forms in web applications are an essential interface for user input. However, form markup can quickly become tedious to write and maintain because of form control naming and their numerous attributes. Rails deals away with these complexities by providing view helpers for generating form markup. However, since they have different use-cases, developers are required to know all the differences between similar helper methods before putting them to use.</p>
<p>In this guide you will:</p>
<ul>
	<li>Create search forms and similar kind of generic forms not representing any specific model in your application</li>
	<li>Make model-centric forms for creation and editing of specific database records</li>
	<li>Generate select boxes from multiple types of data</li>
	<li>Understand the date and time helpers Rails provides</li>
	<li>Learn what makes a file upload form different</li>
	<li>Learn some cases of building forms to external resources</li>
	<li>Find out where to look for complex forms</li>
</ul>

            <div id="subCol">
        <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
        <ol class="chapters">
<li><a href="#dealing-with-basic-forms">Dealing with Basic Forms</a><ul><li><a href="#a-generic-search-form">A Generic Search Form</a></li> <li><a href="#multiple-hashes-in-form-helper-calls">Multiple Hashes in Form Helper Calls</a></li> <li><a href="#helpers-for-generating-form-elements">Helpers for Generating Form Elements</a></li> <li><a href="#other-helpers-of-interest">Other Helpers of Interest</a></li></ul></li><li><a href="#dealing-with-model-objects">Dealing with Model Objects</a><ul><li><a href="#model-object-helpers">Model Object Helpers</a></li> <li><a href="#binding-a-form-to-an-object">Binding a Form to an Object</a></li> <li><a href="#relying-on-record-identification">Relying on Record Identification</a></li> <li><a href="#how-do-forms-with-put-or-delete-methods-work">How do forms with <span class="caps">PUT</span> or <span class="caps">DELETE</span> methods work?</a></li></ul></li><li><a href="#making-select-boxes-with-ease">Making Select Boxes with Ease</a><ul><li><a href="#the-select-and-option-tags">The Select and Option Tags</a></li> <li><a href="#select-boxes-for-dealing-with-models">Select Boxes for Dealing with Models</a></li> <li><a href="#option-tags-from-a-collection-of-arbitrary-objects">Option Tags from a Collection of Arbitrary Objects</a></li> <li><a href="#time-zone-and-country-select">Time Zone and Country Select</a></li></ul></li><li><a href="#using-date-and-time-form-helpers">Using Date and Time Form Helpers</a><ul><li><a href="#barebones-helpers">Barebones Helpers</a></li> <li><a href="#select-model-object-helpers">Model Object Helpers</a></li> <li><a href="#common-options">Common Options</a></li> <li><a href="#individual-components">Individual Components</a></li></ul></li><li><a href="#uploading-files">Uploading Files</a><ul><li><a href="#what-gets-uploaded">What Gets Uploaded</a></li> <li><a href="#dealing-with-ajax">Dealing with Ajax</a></li></ul></li><li><a href="#customizing-form-builders">Customizing Form Builders</a></li><li><a href="#understanding-parameter-naming-conventions">Understanding Parameter Naming Conventions</a><ul><li><a href="#basic-structures">Basic Structures</a></li> <li><a href="#combining-them">Combining Them</a></li> <li><a href="#using-form-helpers">Using Form Helpers</a></li></ul></li><li><a href="#forms-to-external-resources">Forms to external resources</a></li><li><a href="#building-complex-forms">Building Complex Forms</a></li></ol></div>
    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <div class="note"><p>This guide is not intended to be a complete documentation of available form helpers and their arguments. Please visit <a href="http://api.rubyonrails.org/">the Rails <span class="caps">API</span> documentation</a> for a complete reference.</p></div>
<h3 id="dealing-with-basic-forms">1 Dealing with Basic Forms</h3>
<p>The most basic form helper is <tt>form_tag</tt>.</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_tag do %&gt;
  Form contents
&lt;% end %&gt;
</pre>
</div>
<p>When called without arguments like this, it creates a <tt>&lt;form&gt;</tt> tag which, when submitted, will <span class="caps">POST</span> to the current page. For instance, assuming the current page is <tt>/home/index</tt>, the generated <span class="caps">HTML</span> will look like this (some line breaks added for readability):</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/home/index&quot; method=&quot;post&quot;&gt;
  &lt;div style=&quot;margin:0;padding:0&quot;&gt;
    &lt;input name=&quot;utf8&quot; type=&quot;hidden&quot; value=&quot;&amp;#x2713;&quot; /&gt;
    &lt;input name=&quot;authenticity_token&quot; type=&quot;hidden&quot; value=&quot;f755bb0ed134b76c432144748a6d4b7a7ddf2b71&quot; /&gt;
  &lt;/div&gt;
  Form contents
&lt;/form&gt;
</pre>
</div>
<p>Now, you&#8217;ll notice that the <span class="caps">HTML</span> contains something extra: a <tt>div</tt> element with two hidden input elements inside. This div is important, because the form cannot be successfully submitted without it. The first input element with name <tt>utf8</tt> enforces browsers to properly respect your form&#8217;s character encoding and is generated for all forms whether their actions are &#8220;<span class="caps">GET</span>&#8221; or &#8220;<span class="caps">POST</span>&#8221;. The second input element with name <tt>authenticity_token</tt> is a security feature of Rails called <strong>cross-site request forgery protection</strong>, and form helpers generate it for every non-<span class="caps">GET</span> form (provided that this security feature is enabled). You can read more about this in the <a href="./security.html#_cross_site_reference_forgery_csrf">Security Guide</a>.</p>
<div class="note"><p>Throughout this guide, the <tt>div</tt> with the hidden input elements will be excluded from code samples for brevity.</p></div>
<h4 id="a-generic-search-form">1.1 A Generic Search Form</h4>
<p>One of the most basic forms you see on the web is a search form. This form contains:</p>
<ol>
	<li>a form element with &#8220;<span class="caps">GET</span>&#8221; method,</li>
	<li>a label for the input,</li>
	<li>a text input element, and</li>
	<li>a submit element.</li>
</ol>
<p>To create this form you will use <tt>form_tag</tt>, <tt>label_tag</tt>, <tt>text_field_tag</tt>, and <tt>submit_tag</tt>, respectively. Like this:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_tag(&quot;/search&quot;, :method =&gt; &quot;get&quot;) do %&gt;
  &lt;%= label_tag(:q, &quot;Search for:&quot;) %&gt;
  &lt;%= text_field_tag(:q) %&gt;
  &lt;%= submit_tag(&quot;Search&quot;) %&gt;
&lt;% end %&gt;
</pre>
</div>
<p>This will generate the following <span class="caps">HTML</span>:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/search&quot; method=&quot;get&quot;&gt;
  &lt;label for=&quot;q&quot;&gt;Search for:&lt;/label&gt;
  &lt;input id=&quot;q&quot; name=&quot;q&quot; type=&quot;text&quot; /&gt;
  &lt;input name=&quot;commit&quot; type=&quot;submit&quot; value=&quot;Search&quot; /&gt;
&lt;/form&gt;
</pre>
</div>
<div class="info"><p>For every form input, an ID attribute is generated from its name (&#8220;q&#8221; in the example). These IDs can be very useful for <span class="caps">CSS</span> styling or manipulation of form controls with JavaScript.</p></div>
<p>Besides <tt>text_field_tag</tt> and <tt>submit_tag</tt>, there is a similar helper for <em>every</em> form control in <span class="caps">HTML</span>.</p>
<div class="warning"><p>Always use &#8220;<span class="caps">GET</span>&#8221; as the method for search forms. This allows users to bookmark a specific search and get back to it. More generally Rails encourages you to use the right <span class="caps">HTTP</span> verb for an action.</p></div>
<h4 id="multiple-hashes-in-form-helper-calls">1.2 Multiple Hashes in Form Helper Calls</h4>
<p>The <tt>form_tag</tt> helper accepts 2 arguments: the path for the action and an options hash. This hash specifies the method of form submission and <span class="caps">HTML</span> options such as the form element&#8217;s class.</p>
<p>As with the <tt>link_to</tt> helper, the path argument doesn&#8217;t have to be given a string; it can be a hash of <span class="caps">URL</span> parameters recognizable by Rails&#8217; routing mechanism, which will turn the hash into a valid <span class="caps">URL</span>. However, since both arguments to <tt>form_tag</tt> are hashes, you can easily run into a problem if you would like to specify both. For instance, let&#8217;s say you write this:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
form_tag(:controller =&gt; &quot;people&quot;, :action =&gt; &quot;search&quot;, :method =&gt; &quot;get&quot;, :class =&gt; &quot;nifty_form&quot;)
# =&gt; '&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/people/search?method=get&amp;class=nifty_form&quot; method=&quot;post&quot;&gt;'
</pre>
</div>
<p>Here, <tt>method</tt> and <tt>class</tt> are appended to the query string of the generated <span class="caps">URL</span> because you even though you mean to write two hashes, you really only specified one. So you need to tell Ruby which is which by delimiting the first hash (or both) with curly brackets. This will generate the <span class="caps">HTML</span> you expect:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
form_tag({:controller =&gt; &quot;people&quot;, :action =&gt; &quot;search&quot;}, :method =&gt; &quot;get&quot;, :class =&gt; &quot;nifty_form&quot;)
# =&gt; '&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/people/search&quot; method=&quot;get&quot; class=&quot;nifty_form&quot;&gt;'
</pre>
</div>
<h4 id="helpers-for-generating-form-elements">1.3 Helpers for Generating Form Elements</h4>
<p>Rails provides a series of helpers for generating form elements such as checkboxes, text fields, and radio buttons. These basic helpers, with names ending in &#8220;_tag&#8221; (such as <tt>text_field_tag</tt> and <tt>check_box_tag</tt>), generate just a single <tt>&lt;input&gt;</tt> element. The first parameter to these is always the name of the input. When the form is submitted, the name will be passed along with the form data, and will make its way to the <tt>params</tt> hash in the controller with the value entered by the user for that field. For example, if the form contains <tt><%= text_field_tag(:query) %></tt>, then you would be able to get the value of this field in the controller with <tt>params[:query]</tt>.</p>
<p>When naming inputs, Rails uses certain conventions that make it possible to submit parameters with non-scalar values such as arrays or hashes, which will also be accessible in <tt>params</tt>. You can read more about them in <a href="#understanding-parameter-naming-conventions">chapter 7 of this guide</a>. For details on the precise usage of these helpers, please refer to the <a href="http://api.rubyonrails.org/classes/ActionView/Helpers/FormTagHelper.html"><span class="caps">API</span> documentation</a>.</p>
<h5 id="checkboxes">1.3.1 Checkboxes</h5>
<p>Checkboxes are form controls that give the user a set of options they can enable or disable:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= check_box_tag(:pet_dog) %&gt;
&lt;%= label_tag(:pet_dog, &quot;I own a dog&quot;) %&gt;
&lt;%= check_box_tag(:pet_cat) %&gt;
&lt;%= label_tag(:pet_cat, &quot;I own a cat&quot;) %&gt;
</pre>
</div>
<p>This generates the following:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;input id=&quot;pet_dog&quot; name=&quot;pet_dog&quot; type=&quot;checkbox&quot; value=&quot;1&quot; /&gt;
&lt;label for=&quot;pet_dog&quot;&gt;I own a dog&lt;/label&gt;
&lt;input id=&quot;pet_cat&quot; name=&quot;pet_cat&quot; type=&quot;checkbox&quot; value=&quot;1&quot; /&gt;
&lt;label for=&quot;pet_cat&quot;&gt;I own a cat&lt;/label&gt;
</pre>
</div>
<p>The first parameter to <tt>check_box_tag</tt>, of course, is the name of the input. The second parameter, naturally, is the value of the input. This value will be included in the form data (and be present in <tt>params</tt>) when the checkbox is checked.</p>
<h5 id="radio-buttons">1.3.2 Radio Buttons</h5>
<p>Radio buttons, while similar to checkboxes, are controls that specify a set of options in which they are mutually exclusive (i.e., the user can only pick one):</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= radio_button_tag(:age, &quot;child&quot;) %&gt;
&lt;%= label_tag(:age_child, &quot;I am younger than 21&quot;) %&gt;
&lt;%= radio_button_tag(:age, &quot;adult&quot;) %&gt;
&lt;%= label_tag(:age_adult, &quot;I'm over 21&quot;) %&gt;
</pre>
</div>
<p>Output:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;input id=&quot;age_child&quot; name=&quot;age&quot; type=&quot;radio&quot; value=&quot;child&quot; /&gt;
&lt;label for=&quot;age_child&quot;&gt;I am younger than 21&lt;/label&gt;
&lt;input id=&quot;age_adult&quot; name=&quot;age&quot; type=&quot;radio&quot; value=&quot;adult&quot; /&gt;
&lt;label for=&quot;age_adult&quot;&gt;I'm over 21&lt;/label&gt;
</pre>
</div>
<p>As with <tt>check_box_tag</tt>, the second parameter to <tt>radio_button_tag</tt> is the value of the input. Because these two radio buttons share the same name (age) the user will only be able to select one, and <tt>params[:age]</tt> will contain either &#8220;child&#8221; or &#8220;adult&#8221;.</p>
<div class="note"><p>Always use labels for checkbox and radio buttons. They associate text with a specific option and make it easier for users to click the inputs by expanding the clickable region.</p></div>
<h4 id="other-helpers-of-interest">1.4 Other Helpers of Interest</h4>
<p>Other form controls worth mentioning are textareas, password fields, hidden fields, search fields, telephone fields, <span class="caps">URL</span> fields and email fields:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= text_area_tag(:message, &quot;Hi, nice site&quot;, :size =&gt; &quot;24x6&quot;) %&gt;
&lt;%= password_field_tag(:password) %&gt;
&lt;%= hidden_field_tag(:parent_id, &quot;5&quot;) %&gt;
&lt;%= search_field(:user, :name) %&gt;
&lt;%= telephone_field(:user, :phone) %&gt;
&lt;%= url_field(:user, :homepage) %&gt;
&lt;%= email_field(:user, :address) %&gt;
</pre>
</div>
<p>Output:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;textarea id=&quot;message&quot; name=&quot;message&quot; cols=&quot;24&quot; rows=&quot;6&quot;&gt;Hi, nice site&lt;/textarea&gt;
&lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; /&gt;
&lt;input id=&quot;parent_id&quot; name=&quot;parent_id&quot; type=&quot;hidden&quot; value=&quot;5&quot; /&gt;
&lt;input id=&quot;user_name&quot; name=&quot;user[name]&quot; size=&quot;30&quot; type=&quot;search&quot; /&gt;
&lt;input id=&quot;user_phone&quot; name=&quot;user[phone]&quot; size=&quot;30&quot; type=&quot;tel&quot; /&gt;
&lt;input id=&quot;user_homepage&quot; size=&quot;30&quot; name=&quot;user[homepage]&quot; type=&quot;url&quot; /&gt;
&lt;input id=&quot;user_address&quot; size=&quot;30&quot; name=&quot;user[address]&quot; type=&quot;email&quot; /&gt;
</pre>
</div>
<p>Hidden inputs are not shown to the user but instead hold data like any textual input. Values inside them can be changed with JavaScript.</p>
<div class="warning"><p>The search, telephone, <span class="caps">URL</span>, and email inputs are HTML5 controls. If you require your app to have a consistent experience in older browsers, you will need an HTML5 polyfill (provided by <span class="caps">CSS</span> and/or JavaScript). There is definitely <a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills">no shortage of solutions for this</a>, although a couple of popular tools at the moment are <a href="http://www.modernizr.com/">Modernizr</a> and <a href="http://yepnopejs.com/">yepnope</a>, which provide a simple way to add functionality based on the presence of detected HTML5 features.</p></div>
<div class="info"><p>If you&#8217;re using password input fields (for any purpose), you might want to configure your application to prevent those parameters from being logged. You can learn about this in the <a href="security.html#logging">Security Guide</a>.</p></div>
<h3 id="dealing-with-model-objects">2 Dealing with Model Objects</h3>
<h4 id="model-object-helpers">2.1 Model Object Helpers</h4>
<p>A particularly common task for a form is editing or creating a model object. While the <tt>*_tag</tt> helpers can certainly be used for this task they are somewhat verbose as for each tag you would have to ensure the correct parameter name is used and set the default value of the input appropriately. Rails provides helpers tailored to this task. These helpers lack the _tag suffix, for example <tt>text_field</tt>, <tt>text_area</tt>.</p>
<p>For these helpers the first argument is the name of an instance variable and the second is the name of a method (usually an attribute) to call on that object. Rails will set the value of the input control to the return value of that method for the object and set an appropriate input name. If your controller has defined <tt>@person</tt> and that person&#8217;s name is Henry then a form containing:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= text_field(:person, :name) %&gt;
</pre>
</div>
<p>will produce output similar to</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;input id=&quot;person_name&quot; name=&quot;person[name]&quot; type=&quot;text&quot; value=&quot;Henry&quot;/&gt;
</pre>
</div>
<p>Upon form submission the value entered by the user will be stored in <tt>params[:person][:name]</tt>. The <tt>params[:person]</tt> hash is suitable for passing to <tt>Person.new</tt> or, if <tt>@person</tt> is an instance of Person, <tt>@person.update_attributes</tt>. While the name of an attribute is the most common second parameter to these helpers this is not compulsory. In the example above, as long as person objects have a <tt>name</tt> and a <tt>name=</tt> method Rails will be happy.</p>
<div class="warning"><p>You must pass the name of an instance variable, i.e. <tt>:person</tt> or <tt>"person"</tt>, not an actual instance of your model object.</p></div>
<p>Rails provides helpers for displaying the validation errors associated with a model object. These are covered in detail by the <a href="./active_record_validations_callbacks.html#displaying-validation-errors-in-the-view">Active Record Validations and Callbacks</a> guide.</p>
<h4 id="binding-a-form-to-an-object">2.2 Binding a Form to an Object</h4>
<p>While this is an increase in comfort it is far from perfect. If Person has many attributes to edit then we would be repeating the name of the edited object many times. What we want to do is somehow bind a form to a model object, which is exactly what <tt>form_for</tt> does.</p>
<p>Assume we have a controller for dealing with articles <tt>app/controllers/articles_controller.rb</tt>:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def new
  @article = Article.new
end
</pre>
</div>
<p>The corresponding view <tt>app/views/articles/new.html.erb</tt> using <tt>form_for</tt> looks like this:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_for @article, :url =&gt; { :action =&gt; &quot;create&quot; }, :html =&gt; {:class =&gt; &quot;nifty_form&quot;} do |f| %&gt;
  &lt;%= f.text_field :title %&gt;
  &lt;%= f.text_area :body, :size =&gt; &quot;60x12&quot; %&gt;
  &lt;%= f.submit &quot;Create&quot; %&gt;
&lt;% end %&gt;
</pre>
</div>
<p>There are a few things to note here:</p>
<ol>
	<li><tt>@article</tt> is the actual object being edited.</li>
	<li>There is a single hash of options. Routing options are passed in the <tt>:url</tt> hash, <span class="caps">HTML</span> options are passed in the <tt>:html</tt> hash.</li>
	<li>The <tt>form_for</tt> method yields a <strong>form builder</strong> object (the <tt>f</tt> variable).</li>
	<li>Methods to create form controls are called <strong>on</strong> the form builder object <tt>f</tt></li>
</ol>
<p>The resulting <span class="caps">HTML</span> is:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/articles/create&quot; method=&quot;post&quot; class=&quot;nifty_form&quot;&gt;
  &lt;input id=&quot;article_title&quot; name=&quot;article[title]&quot; size=&quot;30&quot; type=&quot;text&quot; /&gt;
  &lt;textarea id=&quot;article_body&quot; name=&quot;article[body]&quot; cols=&quot;60&quot; rows=&quot;12&quot;&gt;&lt;/textarea&gt;
  &lt;input name=&quot;commit&quot; type=&quot;submit&quot; value=&quot;Create&quot; /&gt;
&lt;/form&gt;
</pre>
</div>
<p>The name passed to <tt>form_for</tt> controls the key used in <tt>params</tt> to access the form&#8217;s values. Here the name is <tt>article</tt> and so all the inputs have names of the form <tt>article[<em>attribute_name</em>]</tt>. Accordingly, in the <tt>create</tt> action <tt>params[:article]</tt> will be a hash with keys <tt>:title</tt> and <tt>:body</tt>. You can read more about the significance of input names in the parameter_names section.</p>
<p>The helper methods called on the form builder are identical to the model object helpers except that it is not necessary to specify which object is being edited since this is already managed by the form builder.</p>
<p>You can create a similar binding without actually creating <tt>&lt;form&gt;</tt> tags with the <tt>fields_for</tt> helper. This is useful for editing additional model objects with the same form. For example if you had a Person model with an associated ContactDetail model you could create a form for creating both like so:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_for @person, :url =&gt; { :action =&gt; &quot;create&quot; } do |person_form| %&gt;
  &lt;%= person_form.text_field :name %&gt;
  &lt;%= fields_for @person.contact_detail do |contact_details_form| %&gt;
    &lt;%= contact_details_form.text_field :phone_number %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
</pre>
</div>
<p>which produces the following output:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/people/create&quot; class=&quot;new_person&quot; id=&quot;new_person&quot; method=&quot;post&quot;&gt;
  &lt;input id=&quot;person_name&quot; name=&quot;person[name]&quot; size=&quot;30&quot; type=&quot;text&quot; /&gt;
  &lt;input id=&quot;contact_detail_phone_number&quot; name=&quot;contact_detail[phone_number]&quot; size=&quot;30&quot; type=&quot;text&quot; /&gt;
&lt;/form&gt;
</pre>
</div>
<p>The object yielded by <tt>fields_for</tt> is a form builder like the one yielded by <tt>form_for</tt> (in fact <tt>form_for</tt> calls <tt>fields_for</tt> internally).</p>
<h4 id="relying-on-record-identification">2.3 Relying on Record Identification</h4>
<p>The Article model is directly available to users of the application, so &#8212; following the best practices for developing with Rails &#8212; you should declare it <strong>a resource</strong>:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :articles
</pre>
</div>
<div class="info"><p>Declaring a resource has a number of side-affects. See <a href="routing.html#resource-routing-the-rails-default">Rails Routing From the Outside In</a> for more information on setting up and using resources.</p></div>
<p>When dealing with RESTful resources, calls to <tt>form_for</tt> can get significantly easier if you rely on <strong>record identification</strong>. In short, you can just pass the model instance and have Rails figure out model name and the rest:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
## Creating a new article
# long-style:
form_for(@article, :url =&gt; articles_path)
# same thing, short-style (record identification gets used):
form_for(@article)

## Editing an existing article
# long-style:
form_for(@article, :url =&gt; article_path(@article), :html =&gt; { :method =&gt; &quot;put&quot; })
# short-style:
form_for(@article)
</pre>
</div>
<p>Notice how the short-style <tt>form_for</tt> invocation is conveniently the same, regardless of the record being new or existing. Record identification is smart enough to figure out if the record is new by asking <tt>record.new_record?</tt>. It also selects the correct path to submit to and the name based on the class of the object.</p>
<p>Rails will also automatically set the <tt>class</tt> and <tt>id</tt> of the form appropriately: a form creating an article would have <tt>id</tt> and <tt>class</tt> <tt>new_article</tt>. If you were editing the article with id 23, the <tt>class</tt> would be set to <tt>edit_article</tt> and the id to <tt>edit_article_23</tt>. These attributes will be omitted for brevity in the rest of this guide.</p>
<div class="warning"><p>When you&#8217;re using <span class="caps">STI</span> (single-table inheritance) with your models, you can&#8217;t rely on record identification on a subclass if only their parent class is declared a resource. You will have to specify the model name, <tt>:url</tt>, and <tt>:method</tt> explicitly.</p></div>
<h5 id="dealing-with-namespaces">2.3.1 Dealing with Namespaces</h5>
<p>If you have created namespaced routes, <tt>form_for</tt> has a nifty shorthand for that too. If your application has an admin namespace then</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
form_for [:admin, @article]
</pre>
</div>
<p>will create a form that submits to the articles controller inside the admin namespace (submitting to <tt>admin_article_path(@article)</tt> in the case of an update). If you have several levels of namespacing then the syntax is similar:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
form_for [:admin, :management, @article]
</pre>
</div>
<p>For more information on Rails&#8217; routing system and the associated conventions, please see the <a href="routing.html">routing guide</a>.</p>
<h4 id="how-do-forms-with-put-or-delete-methods-work">2.4 How do forms with <span class="caps">PUT</span> or <span class="caps">DELETE</span> methods work?</h4>
<p>The Rails framework encourages RESTful design of your applications, which means you&#8217;ll be making a lot of &#8220;<span class="caps">PUT</span>&#8221; and &#8220;<span class="caps">DELETE</span>&#8221; requests (besides &#8220;<span class="caps">GET</span>&#8221; and &#8220;<span class="caps">POST</span>&#8221;). However, most browsers <em>don&#8217;t support</em> methods other than &#8220;<span class="caps">GET</span>&#8221; and &#8220;<span class="caps">POST</span>&#8221; when it comes to submitting forms.</p>
<p>Rails works around this issue by emulating other methods over <span class="caps">POST</span> with a hidden input named <tt>"_method"</tt>, which is set to reflect the desired method:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
form_tag(search_path, :method =&gt; &quot;put&quot;)
</pre>
</div>
<p>output:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/search&quot; method=&quot;post&quot;&gt;
  &lt;div style=&quot;margin:0;padding:0&quot;&gt;
    &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;put&quot; /&gt;
    &lt;input name=&quot;utf8&quot; type=&quot;hidden&quot; value=&quot;&amp;#x2713;&quot; /&gt;
    &lt;input name=&quot;authenticity_token&quot; type=&quot;hidden&quot; value=&quot;f755bb0ed134b76c432144748a6d4b7a7ddf2b71&quot; /&gt;
  &lt;/div&gt;
  ...
</pre>
</div>
<p>When parsing POSTed data, Rails will take into account the special <tt>_method</tt> parameter and acts as if the <span class="caps">HTTP</span> method was the one specified inside it (&#8220;<span class="caps">PUT</span>&#8221; in this example).</p>
<h3 id="making-select-boxes-with-ease">3 Making Select Boxes with Ease</h3>
<p>Select boxes in <span class="caps">HTML</span> require a significant amount of markup (one <tt>OPTION</tt> element for each option to choose from), therefore it makes the most sense for them to be dynamically generated.</p>
<p>Here is what the markup might look like:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;select name=&quot;city_id&quot; id=&quot;city_id&quot;&gt;
  &lt;option value=&quot;1&quot;&gt;Lisbon&lt;/option&gt;
  &lt;option value=&quot;2&quot;&gt;Madrid&lt;/option&gt;
  ...
  &lt;option value=&quot;12&quot;&gt;Berlin&lt;/option&gt;
&lt;/select&gt;
</pre>
</div>
<p>Here you have a list of cities whose names are presented to the user. Internally the application only wants to handle their IDs so they are used as the options&#8217; value attribute. Let&#8217;s see how Rails can help out here.</p>
<h4 id="the-select-and-option-tags">3.1 The Select and Option Tags</h4>
<p>The most generic helper is <tt>select_tag</tt>, which &#8212; as the name implies &#8212; simply generates the <tt>SELECT</tt> tag that encapsulates an options string:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= select_tag(:city_id, '&lt;option value=&quot;1&quot;&gt;Lisbon&lt;/option&gt;...') %&gt;
</pre>
</div>
<p>This is a start, but it doesn&#8217;t dynamically create the option tags. You can generate option tags with the <tt>options_for_select</tt> helper:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= options_for_select([['Lisbon', 1], ['Madrid', 2], ...]) %&gt;

output:

&lt;option value=&quot;1&quot;&gt;Lisbon&lt;/option&gt;
&lt;option value=&quot;2&quot;&gt;Madrid&lt;/option&gt;
...
</pre>
</div>
<p>The first argument to <tt>options_for_select</tt> is a nested array where each element has two elements: option text (city name) and option value (city id). The option value is what will be submitted to your controller. Often this will be the id of a corresponding database object but this does not have to be the case.</p>
<p>Knowing this, you can combine <tt>select_tag</tt> and <tt>options_for_select</tt> to achieve the desired, complete markup:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= select_tag(:city_id, options_for_select(...)) %&gt;
</pre>
</div>
<p><tt>options_for_select</tt> allows you to pre-select an option by passing its value.</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= options_for_select([['Lisbon', 1], ['Madrid', 2], ...], 2) %&gt;

output:

&lt;option value=&quot;1&quot;&gt;Lisbon&lt;/option&gt;
&lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;Madrid&lt;/option&gt;
...
</pre>
</div>
<p>Whenever Rails sees that the internal value of an option being generated matches this value, it will add the <tt>selected</tt> attribute to that option.</p>
<div class="info"><p>The second argument to <tt>options_for_select</tt> must be exactly equal to the desired internal value. In particular if the value is the integer 2 you cannot pass &#8220;2&#8221; to <tt>options_for_select</tt> &#8212; you must pass 2. Be aware of values extracted from the <tt>params</tt> hash as they are all strings.</p></div>
<h4 id="select-boxes-for-dealing-with-models">3.2 Select Boxes for Dealing with Models</h4>
<p>In most cases form controls will be tied to a specific database model and as you might expect Rails provides helpers tailored for that purpose. Consistent with other form helpers, when dealing with models you drop the <tt>_tag</tt> suffix from <tt>select_tag</tt>:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# controller:
@person = Person.new(:city_id =&gt; 2)
</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
# view:
&lt;%= select(:person, :city_id, [['Lisbon', 1], ['Madrid', 2], ...]) %&gt;
</pre>
</div>
<p>Notice that the third parameter, the options array, is the same kind of argument you pass to <tt>options_for_select</tt>. One advantage here is that you don&#8217;t have to worry about pre-selecting the correct city if the user already has one &#8212; Rails will do this for you by reading from the <tt>@person.city_id</tt> attribute.</p>
<p>As with other helpers, if you were to use the <tt>select</tt> helper on a form builder scoped to the <tt>@person</tt> object, the syntax would be:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
# select on a form builder
&lt;%= f.select(:city_id, ...) %&gt;
</pre>
</div>
<div class="warning"><p>If you are using <tt>select</tt> (or similar helpers such as <tt>collection_select</tt>, <tt>select_tag</tt>) to set a <tt>belongs_to</tt> association you must pass the name of the foreign key (in the example above <tt>city_id</tt>), not the name of association itself. If you specify <tt>city</tt> instead of <tt>city_id</tt> Active Record will raise an error along the lines of <tt> ActiveRecord::AssociationTypeMismatch: City(#17815740) expected, got String(#1138750) </tt> when you pass the <tt>params</tt> hash to <tt>Person.new</tt> or <tt>update_attributes</tt>. Another way of looking at this is that form helpers only edit attributes. You should also be aware of the potential security ramifications of allowing users to edit foreign keys directly. You may wish to consider the use of <tt>attr_protected</tt> and <tt>attr_accessible</tt>. For further details on this, see the <a href="security.html#_mass_assignment">Ruby On Rails Security Guide</a>.</p></div>
<h4 id="option-tags-from-a-collection-of-arbitrary-objects">3.3 Option Tags from a Collection of Arbitrary Objects</h4>
<p>Generating options tags with <tt>options_for_select</tt> requires that you create an array containing the text and value for each option. But what if you had a City model (perhaps an Active Record one) and you wanted to generate option tags from a collection of those objects? One solution would be to make a nested array by iterating over them:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;% cities_array = City.all.map { |city| [city.name, city.id] } %&gt;
&lt;%= options_for_select(cities_array) %&gt;
</pre>
</div>
<p>This is a perfectly valid solution, but Rails provides a less verbose alternative: <tt>options_from_collection_for_select</tt>. This helper expects a collection of arbitrary objects and two additional arguments: the names of the methods to read the option <strong>value</strong> and <strong>text</strong> from, respectively:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= options_from_collection_for_select(City.all, :id, :name) %&gt;
</pre>
</div>
<p>As the name implies, this only generates option tags. To generate a working select box you would need to use it in conjunction with <tt>select_tag</tt>, just as you would with <tt>options_for_select</tt>. When working with model objects, just as <tt>select</tt> combines <tt>select_tag</tt> and <tt>options_for_select</tt>, <tt>collection_select</tt> combines <tt>select_tag</tt> with <tt>options_from_collection_for_select</tt>.</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= collection_select(:person, :city_id, City.all, :id, :name) %&gt;
</pre>
</div>
<p>To recap, <tt>options_from_collection_for_select</tt> is to <tt>collection_select</tt> what <tt>options_for_select</tt> is to <tt>select</tt>.</p>
<div class="note"><p>Pairs passed to <tt>options_for_select</tt> should have the name first and the id second, however with <tt>options_from_collection_for_select</tt> the first argument is the value method and the second the text method.</p></div>
<h4 id="time-zone-and-country-select">3.4 Time Zone and Country Select</h4>
<p>To leverage time zone support in Rails, you have to ask your users what time zone they are in. Doing so would require generating select options from a list of pre-defined TimeZone objects using <tt>collection_select</tt>, but you can simply use the <tt>time_zone_select</tt> helper that already wraps this:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= time_zone_select(:person, :time_zone) %&gt;
</pre>
</div>
<p>There is also <tt>time_zone_options_for_select</tt> helper for a more manual (therefore more customizable) way of doing this. Read the <span class="caps">API</span> documentation to learn about the possible arguments for these two methods.</p>
<p>Rails <em>used</em> to have a <tt>country_select</tt> helper for choosing countries, but this has been extracted to the <a href="https://github.com/chrislerum/country_select">country_select plugin</a>. When using this, be aware that the exclusion or inclusion of certain names from the list can be somewhat controversial (and was the reason this functionality was extracted from Rails).</p>
<h3 id="using-date-and-time-form-helpers">4 Using Date and Time Form Helpers</h3>
<p>The date and time helpers differ from all the other form helpers in two important respects:</p>
<ol>
	<li>Dates and times are not representable by a single input element. Instead you have several, one for each component (year, month, day etc.) and so there is no single value in your <tt>params</tt> hash with your date or time.</li>
	<li>Other helpers use the <tt>_tag</tt> suffix to indicate whether a helper is a barebones helper or one that operates on model objects. With dates and times, <tt>select_date</tt>, <tt>select_time</tt> and <tt>select_datetime</tt> are the barebones helpers, <tt>date_select</tt>, <tt>time_select</tt> and <tt>datetime_select</tt> are the equivalent model object helpers.</li>
</ol>
<p>Both of these families of helpers will create a series of select boxes for the different components (year, month, day etc.).</p>
<h4 id="barebones-helpers">4.1 Barebones Helpers</h4>
<p>The <tt>select_*</tt> family of helpers take as their first argument an instance of Date, Time or DateTime that is used as the currently selected value. You may omit this parameter, in which case the current date is used. For example</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= select_date Date.today, :prefix =&gt; :start_date %&gt;
</pre>
</div>
<p>outputs (with actual option values omitted for brevity)</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;select id=&quot;start_date_year&quot; name=&quot;start_date[year]&quot;&gt; ... &lt;/select&gt;
&lt;select id=&quot;start_date_month&quot; name=&quot;start_date[month]&quot;&gt; ... &lt;/select&gt;
&lt;select id=&quot;start_date_day&quot; name=&quot;start_date[day]&quot;&gt; ... &lt;/select&gt;
</pre>
</div>
<p>The above inputs would result in <tt>params[:start_date]</tt> being a hash with keys <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>. To get an actual Time or Date object you would have to extract these values and pass them to the appropriate constructor, for example</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Date.civil(params[:start_date][:year].to_i, params[:start_date][:month].to_i, params[:start_date][:day].to_i)
</pre>
</div>
<p>The <tt>:prefix</tt> option is the key used to retrieve the hash of date components from the <tt>params</tt> hash. Here it was set to <tt>start_date</tt>, if omitted it will default to <tt>date</tt>.</p>
<h4 id="select-model-object-helpers">4.2 Model Object Helpers</h4>
<p><tt>select_date</tt> does not work well with forms that update or create Active Record objects as Active Record expects each element of the <tt>params</tt> hash to correspond to one attribute.
The model object helpers for dates and times submit parameters with special names, when Active Record sees parameters with such names it knows they must be combined with the other parameters and given to a constructor appropriate to the column type. For example:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= date_select :person, :birth_date %&gt;
</pre>
</div>
<p>outputs (with actual option values omitted for brevity)</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;select id=&quot;person_birth_date_1i&quot; name=&quot;person[birth_date(1i)]&quot;&gt; ... &lt;/select&gt;
&lt;select id=&quot;person_birth_date_2i&quot; name=&quot;person[birth_date(2i)]&quot;&gt; ... &lt;/select&gt;
&lt;select id=&quot;person_birth_date_3i&quot; name=&quot;person[birth_date(3i)]&quot;&gt; ... &lt;/select&gt;
</pre>
</div>
<p>which results in a <tt>params</tt> hash like</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
{:person =&gt; {'birth_date(1i)' =&gt; '2008', 'birth_date(2i)' =&gt; '11', 'birth_date(3i)' =&gt; '22'}}
</pre>
</div>
<p>When this is passed to <tt>Person.new</tt> (or <tt>update_attributes</tt>), Active Record spots that these parameters should all be used to construct the <tt>birth_date</tt> attribute and uses the suffixed information to determine in which order it should pass these parameters to functions such as <tt>Date.civil</tt>.</p>
<h4 id="common-options">4.3 Common Options</h4>
<p>Both families of helpers use the same core set of functions to generate the individual select tags and so both accept largely the same options. In particular, by default Rails will generate year options 5 years either side of the current year. If this is not an appropriate range, the <tt>:start_year</tt> and <tt>:end_year</tt> options override this. For an exhaustive list of the available options, refer to the <a href="http://api.rubyonrails.org/classes/ActionView/Helpers/DateHelper.html"><span class="caps">API</span> documentation</a>.</p>
<p>As a rule of thumb you should be using <tt>date_select</tt> when working with model objects and <tt>select_date</tt> in other cases, such as a search form which filters results by date.</p>
<div class="note"><p>In many cases the built-in date pickers are clumsy as they do not aid the user in working out the relationship between the date and the day of the week.</p></div>
<h4 id="individual-components">4.4 Individual Components</h4>
<p>Occasionally you need to display just a single date component such as a year or a month. Rails provides a series of helpers for this, one for each component <tt>select_year</tt>, <tt>select_month</tt>, <tt>select_day</tt>, <tt>select_hour</tt>, <tt>select_minute</tt>, <tt>select_second</tt>. These helpers are fairly straightforward. By default they will generate an input field named after the time component (for example &#8220;year&#8221; for <tt>select_year</tt>, &#8220;month&#8221; for <tt>select_month</tt> etc.) although this can be overridden with the  <tt>:field_name</tt> option. The <tt>:prefix</tt> option works in the same way that it does for <tt>select_date</tt> and <tt>select_time</tt> and has the same default value.</p>
<p>The first parameter specifies which value should be selected and can either be an instance of a Date, Time or DateTime, in which case the relevant component will be extracted, or a numerical value. For example</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= select_year(2009) %&gt;
&lt;%= select_year(Time.now) %&gt;
</pre>
</div>
<p>will produce the same output if the current year is 2009 and the value chosen by the user can be retrieved by <tt>params[:date][:year]</tt>.</p>
<h3 id="uploading-files">5 Uploading Files</h3>
<p>A common task is uploading some sort of file, whether it&#8217;s a picture of a person or a <span class="caps">CSV</span> file containing data to process. The most important thing to remember with file uploads is that the rendered form&#8217;s encoding <strong><span class="caps">MUST</span></strong> be set to &#8220;multipart/form-data&#8221;. If you use <tt>form_for</tt>, this is done automatically. If you use <tt>form_tag</tt>, you must set it yourself, as per the following example.</p>
<p>The following two forms both upload a file.</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_tag({:action =&gt; :upload}, :multipart =&gt; true) do %&gt;
  &lt;%= file_field_tag 'picture' %&gt;
&lt;% end %&gt;

&lt;%= form_for @person do |f| %&gt;
  &lt;%= f.file_field :picture %&gt;
&lt;% end %&gt;
</pre>
</div>
<div class="note"><p>Since Rails 3.1, forms rendered using <tt>form_for</tt> have their encoding set to <tt>multipart/form-data</tt> automatically once a <tt>file_field</tt> is used inside the block. Previous versions required you to set this explicitly.</p></div>
<p>Rails provides the usual pair of helpers: the barebones <tt>file_field_tag</tt> and the model oriented <tt>file_field</tt>. The only difference with other helpers is that you cannot set a default value for file inputs as this would have no meaning. As you would expect in the first case the uploaded file is in <tt>params[:picture]</tt> and in the second case in <tt>params[:person][:picture]</tt>.</p>
<h4 id="what-gets-uploaded">5.1 What Gets Uploaded</h4>
<p>The object in the <tt>params</tt> hash is an instance of a subclass of IO. Depending on the size of the uploaded file it may in fact be a StringIO or an instance of File backed by a temporary file. In both cases the object will have an <tt>original_filename</tt> attribute containing the name the file had on the user&#8217;s computer and a <tt>content_type</tt> attribute containing the <span class="caps">MIME</span> type of the uploaded file. The following snippet saves the uploaded content in <tt>#{Rails.root}/public/uploads</tt> under the same name as the original file (assuming the form was the one in the previous example).</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def upload
  uploaded_io = params[:person][:picture]
  File.open(Rails.root.join('public', 'uploads', uploaded_io.original_filename), 'w') do |file|
    file.write(uploaded_io.read)
  end
end
</pre>
</div>
<p>Once a file has been uploaded, there are a multitude of potential tasks, ranging from where to store the files (on disk, Amazon S3, etc) and associating them with models to resizing image files and generating thumbnails. The intricacies of this are beyond the scope of this guide, but there are several libraries designed to assist with these. Two of the better known ones are <a href="https://github.com/jnicklas/carrierwave">CarrierWave</a> and <a href="http://www.thoughtbot.com/projects/paperclip">Paperclip</a>.</p>
<div class="note"><p>If the user has not selected a file the corresponding parameter will be an empty string.</p></div>
<h4 id="dealing-with-ajax">5.2 Dealing with Ajax</h4>
<p>Unlike other forms making an asynchronous file upload form is not as simple as providing <tt>form_for</tt> with <tt>:remote =&gt; true</tt>. With an Ajax form the serialization is done by JavaScript running inside the browser and since JavaScript cannot read files from your hard drive the file cannot be uploaded. The most common workaround is to use an invisible iframe that serves as the target for the form submission.</p>
<h3 id="customizing-form-builders">6 Customizing Form Builders</h3>
<p>As mentioned previously the object yielded by <tt>form_for</tt> and <tt>fields_for</tt> is an instance of FormBuilder (or a subclass thereof). Form builders encapsulate the notion of displaying form elements for a single object. While you can of course write helpers for your forms in the usual way you can also subclass FormBuilder and add the helpers there. For example</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_for @person do |f| %&gt;
  &lt;%= text_field_with_label f, :first_name %&gt;
&lt;% end %&gt;
</pre>
</div>
<p>can be replaced with</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_for @person, :builder =&gt; LabellingFormBuilder do |f| %&gt;
  &lt;%= f.text_field :first_name %&gt;
&lt;% end %&gt;
</pre>
</div>
<p>by defining a LabellingFormBuilder class similar to the following:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class LabellingFormBuilder &lt; ActionView::Helpers::FormBuilder
  def text_field(attribute, options={})
    label(attribute) + super
  end
end
</pre>
</div>
<p>If you reuse this frequently you could define a <tt>labeled_form_for</tt> helper that automatically applies the <tt>:builder => LabellingFormBuilder</tt> option.</p>
<p>The form builder used also determines what happens when you do</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= render :partial =&gt; f %&gt;
</pre>
</div>
<p>If <tt>f</tt> is an instance of FormBuilder then this will render the <tt>form</tt> partial, setting the partial&#8217;s object to the form builder. If the form builder is of class LabellingFormBuilder then the <tt>labelling_form</tt> partial would be rendered instead.</p>
<h3 id="understanding-parameter-naming-conventions">7 Understanding Parameter Naming Conventions</h3>
<p>As you&#8217;ve seen in the previous sections, values from forms can be at the top level of the <tt>params</tt> hash or nested in another hash. For example in a standard <tt>create</tt>
action for a Person model, <tt>params[:model]</tt> would usually be a hash of all the attributes for the person to create. The <tt>params</tt> hash can also contain arrays, arrays of hashes and so on.</p>
<p>Fundamentally <span class="caps">HTML</span> forms don&#8217;t know about any sort of structured data, all they generate is name–value pairs, where pairs are just plain strings. The arrays and hashes you see in your application are the result of some parameter naming conventions that Rails uses.</p>
<div class="info"><p>You may find you can try out examples in this section faster by using the console to directly invoke Rails&#8217; parameter parser. For example,</p></div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
ActionController::UrlEncodedPairParser.parse_query_parameters &quot;name=fred&amp;phone=0123456789&quot;
# =&gt; {&quot;name&quot;=&gt;&quot;fred&quot;, &quot;phone&quot;=&gt;&quot;0123456789&quot;}
</pre>
</div>
<h4 id="basic-structures">7.1 Basic Structures</h4>
<p>The two basic structures are arrays and hashes. Hashes mirror the syntax used for accessing the value in <tt>params</tt>. For example if a form contains</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;input id=&quot;person_name&quot; name=&quot;person[name]&quot; type=&quot;text&quot; value=&quot;Henry&quot;/&gt;
</pre>
</div>
<p>the <tt>params</tt> hash will contain</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
{'person' =&gt; {'name' =&gt; 'Henry'}}
</pre>
</div>
<p>and <tt>params[:person][:name]</tt> will retrieve the submitted value in the controller.</p>
<p>Hashes can be nested as many levels as required, for example</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;input id=&quot;person_address_city&quot; name=&quot;person[address][city]&quot; type=&quot;text&quot; value=&quot;New York&quot;/&gt;
</pre>
</div>
<p>will result in the <tt>params</tt> hash being</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
{'person' =&gt; {'address' =&gt; {'city' =&gt; 'New York'}}}
</pre>
</div>
<p>Normally Rails ignores duplicate parameter names. If the parameter name contains an empty set of square brackets [] then they will be accumulated in an array. If you wanted people to be able to input multiple phone numbers, you could place this in the form:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;input name=&quot;person[phone_number][]&quot; type=&quot;text&quot;/&gt;
&lt;input name=&quot;person[phone_number][]&quot; type=&quot;text&quot;/&gt;
&lt;input name=&quot;person[phone_number][]&quot; type=&quot;text&quot;/&gt;
</pre>
</div>
<p>This would result in <tt>params[:person][:phone_number]</tt> being an array.</p>
<h4 id="combining-them">7.2 Combining Them</h4>
<p>We can mix and match these two concepts. For example, one element of a hash might be an array as in the previous example, or you can have an array of hashes. For example a form might let you create any number of addresses by repeating the following form fragment</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;input name=&quot;addresses[][line1]&quot; type=&quot;text&quot;/&gt;
&lt;input name=&quot;addresses[][line2]&quot; type=&quot;text&quot;/&gt;
&lt;input name=&quot;addresses[][city]&quot; type=&quot;text&quot;/&gt;
</pre>
</div>
<p>This would result in <tt>params[:addresses]</tt> being an array of hashes with keys <tt>line1</tt>, <tt>line2</tt> and <tt>city</tt>. Rails decides to start accumulating values in a new hash whenever it encounters an input name that already exists in the current hash.</p>
<p>There&#8217;s a restriction, however, while hashes can be nested arbitrarily, only one level of &#8220;arrayness&#8221; is allowed. Arrays can be usually replaced by hashes, for example instead of having an array of model objects one can have a hash of model objects keyed by their id, an array index or some other parameter.</p>
<div class="warning"><p>Array parameters do not play well with the <tt>check_box</tt> helper. According to the <span class="caps">HTML</span> specification unchecked checkboxes submit no value. However it is often convenient for a checkbox to always submit a value. The <tt>check_box</tt> helper fakes this by creating an auxiliary hidden input with the same name. If the checkbox is unchecked only the hidden input is submitted and if it is checked then both are submitted but the value submitted by the checkbox takes precedence. When working with array parameters this duplicate submission will confuse Rails since duplicate input names are how it decides when to start a new array element. It is preferable to either use <tt>check_box_tag</tt> or to use hashes instead of arrays.</p></div>
<h4 id="using-form-helpers">7.3 Using Form Helpers</h4>
<p>The previous sections did not use the Rails form helpers at all. While you can craft the input names yourself and pass them directly to helpers such as <tt>text_field_tag</tt> Rails also provides higher level support. The two tools at your disposal here are the name parameter to <tt>form_for</tt> and <tt>fields_for</tt> and the <tt>:index</tt> option that helpers take.</p>
<p>You might want to render a form with a set of edit fields for each of a person&#8217;s addresses. For example:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_for @person do |person_form| %&gt;
  &lt;%= person_form.text_field :name %&gt;
  &lt;% @person.addresses.each do |address| %&gt;
    &lt;%= person_form.fields_for address, :index =&gt; address do |address_form|%&gt;
      &lt;%= address_form.text_field :city %&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
</pre>
</div>
<p>Assuming the person had two addresses, with ids 23 and 45 this would create output similar to this:</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;form accept-charset=&quot;UTF-8&quot; action=&quot;/people/1&quot; class=&quot;edit_person&quot; id=&quot;edit_person_1&quot; method=&quot;post&quot;&gt;
  &lt;input id=&quot;person_name&quot; name=&quot;person[name]&quot; size=&quot;30&quot; type=&quot;text&quot; /&gt;
  &lt;input id=&quot;person_address_23_city&quot; name=&quot;person[address][23][city]&quot; size=&quot;30&quot; type=&quot;text&quot; /&gt;
  &lt;input id=&quot;person_address_45_city&quot; name=&quot;person[address][45][city]&quot; size=&quot;30&quot; type=&quot;text&quot; /&gt;
&lt;/form&gt;
</pre>
</div>
<p>This will result in a <tt>params</tt> hash that looks like</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
{'person' =&gt; {'name' =&gt; 'Bob', 'address' =&gt; {'23' =&gt; {'city' =&gt; 'Paris'}, '45' =&gt; {'city' =&gt; 'London'}}}}
</pre>
</div>
<p>Rails knows that all these inputs should be part of the person hash because you called <tt>fields_for</tt> on the first form builder. By specifying an <tt>:index</tt> option you&#8217;re telling Rails that instead of naming the inputs <tt>person[address][city]</tt> it should insert that index surrounded by [] between the address and the city. If you pass an Active Record object as we did then Rails will call <tt>to_param</tt> on it, which by default returns the database id. This is often useful as it is then easy to locate which Address record should be modified. You can pass numbers with some other significance, strings or even <tt>nil</tt> (which will result in an array parameter being created).</p>
<p>To create more intricate nestings, you can specify the first part of the input name (<tt>person[address]</tt> in the previous example) explicitly, for example</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= fields_for 'person[address][primary]', address, :index =&gt; address do |address_form| %&gt;
  &lt;%= address_form.text_field :city %&gt;
&lt;% end %&gt;
</pre>
</div>
<p>will create inputs like</p>
<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;input id=&quot;person_address_primary_1_city&quot; name=&quot;person[address][primary][1][city]&quot; size=&quot;30&quot; type=&quot;text&quot; value=&quot;bologna&quot; /&gt;
</pre>
</div>
<p>As a general rule the final input name is the concatenation of the name given to <tt>fields_for</tt>/<tt>form_for</tt>, the index value and the name of the attribute. You can also pass an <tt>:index</tt> option directly to helpers such as <tt>text_field</tt>, but it is usually less repetitive to specify this at the form builder level rather than on individual input controls.</p>
<p>As a shortcut you can append [] to the name and omit the <tt>:index</tt> option. This is the same as specifying <tt>:index => address</tt> so</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= fields_for 'person[address][primary][]', address do |address_form| %&gt;
  &lt;%= address_form.text_field :city %&gt;
&lt;% end %&gt;
</pre>
</div>
<p>produces exactly the same output as the previous example.</p>
<h3 id="forms-to-external-resources">8 Forms to external resources</h3>
<p>If you need to post some data to an external resource it is still great to build your from using rails form helpers. But sometimes you need to set an <tt>authenticity_token</tt> for this resource. You can do it by passing an <tt>:authenticity_token => 'your_external_token'</tt> parameter to the <tt>form_tag</tt> options:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_tag 'http://farfar.away/form', :authenticity_token =&gt; 'external_token') do %&gt;
  Form contents
&lt;% end %&gt;
</pre>
</div>
<p>Sometimes when you submit data to an external resource, like payment gateway, fields you can use in your form are limited by an external <span class="caps">API</span>. So you may want not to generate an <tt>authenticity_token</tt> hidden field at all. For doing this just pass <tt>false</tt> to the <tt>:authenticity_token</tt> option:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_tag 'http://farfar.away/form', :authenticity_token =&gt; false) do %&gt;
  Form contents
&lt;% end %&gt;
</pre>
</div>
<p>The same technique is available for the <tt>form_for</tt> too:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_for @invoice, :url =&gt; external_url, :authenticity_token =&gt; 'external_token' do |f|
  Form contents
&lt;% end %&gt;
</pre>
</div>
<p>Or if you don&#8217;t want to render an <tt>authenticity_token</tt> field:</p>
<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_for @invoice, :url =&gt; external_url, :authenticity_token =&gt; false do |f|
  Form contents
&lt;% end %&gt;
</pre>
</div>
<h3 id="building-complex-forms">9 Building Complex Forms</h3>
<p>Many apps grow beyond simple forms editing a single object. For example when creating a Person you might want to allow the user to (on the same form) create multiple address records (home, work, etc.). When later editing that person the user should be able to add, remove or amend addresses as necessary. While this guide has shown you all the pieces necessary to handle this, Rails does not yet have a standard end-to-end way of accomplishing this, but many have come up with viable approaches. These include:</p>
<ul>
	<li>As of Rails 2.3, Rails includes <a href="./2_3_release_notes.html#nested-attributes">Nested Attributes</a> and <a href="./2_3_release_notes.html#nested-object-forms">Nested Object Forms</a></li>
	<li>Ryan Bates&#8217; series of Railscasts on <a href="http://railscasts.com/episodes/75">complex forms</a></li>
	<li>Handle Multiple Models in One Form from <a href="http://media.pragprog.com/titles/fr_arr/multiple_models_one_form.pdf">Advanced Rails Recipes</a></li>
	<li>Eloy Duran&#8217;s <a href="https://github.com/alloy/complex-form-examples/">complex-forms-examples</a> application</li>
	<li>Lance Ivy&#8217;s <a href="https://github.com/cainlevy/nested_assignment/tree/master">nested_assignment</a> plugin and <a href="https://github.com/cainlevy/complex-form-examples/tree/cainlevy">sample application</a></li>
	<li>James Golick&#8217;s <a href="https://github.com/jamesgolick/attribute_fu">attribute_fu</a> plugin</li>
</ul>

        <h3>Feedback</h3>
        <p>
          You're encouraged to help improve the quality of this guide.
        </p>
        <p>
          If you see any typos or factual errors you are confident to
          patch, please clone <a href="https://github.com/lifo/docrails">docrails</a>
          and push the change yourself. That branch of Rails has public write access.
          Commits are still reviewed, but that happens after you've submitted your
          contribution. <a href="https://github.com/lifo/docrails">docrails</a> is
          cross-merged with master periodically.
        </p>
        <p>
          You may also find incomplete content, or stuff that is not up to date.
          Please do add any missing documentation for master. Check the
          <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a>
          for style and conventions.
        </p>
        <p>
          If for whatever reason you spot something to fix but cannot patch it yourself, please
          <a href="https://github.com/rails/rails/issues">open an issue</a>.
        </p>
        <p>And last but not least, any kind of discussion regarding Ruby on Rails
          documentation is very welcome in the <a href="http://groups.google.com/group/rubyonrails-docs">rubyonrails-docs mailing list</a>.
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0</a> License</p>
      <p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>
    </div>
  </div>

  <script type="text/javascript" src="javascripts/guides.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushRuby.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushXml.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushSql.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all()
  </script>
</body>
</html>
